<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>袁琼琼的博客</title>
  
  <subtitle>一个想在技术道路走下去的小渣渣，多多关照！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yuanqiongqiong.cn/"/>
  <updated>2019-04-06T06:03:04.000Z</updated>
  <id>https://www.yuanqiongqiong.cn/</id>
  
  <author>
    <name>袁琼琼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从java类加载机制解析变量初始化</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/06/%E4%BB%8Ejava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/06/从java类加载机制解析变量初始化/</id>
    <published>2019-04-06T02:41:41.000Z</published>
    <updated>2019-04-06T06:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​         java类加载机制对我来说总是熟悉又陌生，之前也单独是进行了解过，但总是当时很明白，过了一段时间这块又忘的差不多了。所以，想通过这篇文章对这块知识进行详细的总结。</p><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><p>​        我们知道java代码是运行在jvm上的，这个过程需要经过将源代码编译为class字节码，然后将字节码装载到jvm中行程其可以使用的java类型，这个装载的过程就是java类的加载机制。Java类加载过程可以分为加载，验证，准备，解析，初始化五个阶段，其中验证，准备，解析三个阶段又可以称为连接过程。可以看出，java的连接工作发生在运行期，这为程序提供了高度的灵活性(java 动态扩展特性依赖于此)。下面，我们先看下结合java加载机制后的类对象声明周期图示，然后对相关阶段进行详细介绍。</p><p><img src="/2019/04/06/从java类加载机制解析变量初始化/jvmload.png" alt></p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>​        jvm并没有对类的加载时机进行明确的规范，但是却对类的初始化时机进行了严格的规定（在进行初始化的时候，加载，验证，准备，解析必须完成）。jvm规定必须在“initialize on first active use”是对类进行初始化，即首次使用时必须对类进行初始化。以下几种情况会触发类的初始化过程：</p><p>（1）创建一个类的实例时，new、反射、克隆或反序列化；</p><p>（2）调用某个类的静态方法时；</p><p>（3）使用某个类或接口的静态字段或对该字段赋值时（final字段除外）；</p><p>（4）调用Java的某些反射方法时；</p><p>（5）初始化某个类的子类时；</p><p>（6）在虚拟机启动时某个含有main()方法的那个启动类。</p><p>​         需要注意的是：（1）同一个类在同一个类加载器下只能初始化一次；（2）引用在编译期就能确定的静态常量不会触发初始化；（3）在初始化前必须进行加载和链接；（4）如果这个类有父类并且这个父类没有被初始化,则先初始化父类。</p><h2 id="各阶段介绍"><a href="#各阶段介绍" class="headerlink" title="各阶段介绍"></a>各阶段介绍</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>​     在该阶段，jvm需要完成以下3件事：</p><p>（1）通过一个类的全限定名来获取定义此类的二进制字节流，这个字节流可以来自class文件，网络io，或者动态生成（即动态代理技术的基础）；</p><p>（2）<strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</strong></p><p>（3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。（对于hotspot，Class对象比较特殊，存在于方法区）。</p><p>​     需要说明的是对于数组类而言，本身不通过类加载器创建，它是由java虚拟机直接创建的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​      该阶段是为了保证加载的Class文件符合虚拟机的要求，不会危及虚拟机自身的安全，主要有一下四个检验阶段：</p><p>（1）文件格式验证<br>主要验证字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。<br>（2）元数据验证<br>是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范要求。<br>（3）字节码验证<br>主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。<br>（4）符号引用验证<br>     发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析中。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>​      该阶段正式为类变量分配内存并进行初始化，注意是类变量而不是实例变量，该阶段内存分配发生在方法区。<strong>在该阶段完成后类变量会被置为默认值（final类型的静态变量除外）。</strong></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>​      该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。需要对符号引用和常量引用进行说明如下：</p><p>（1）符号引用</p><p>​      符号引用以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</p><p>（2）直接引用</p><p>​     直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位目标的句柄，它是与虚拟机的内存布局相关的，如果有了直接引用，那引用的目标必定已经存在于内存中。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​      该阶段才真正开始执行类定义中的java程序代码，初始化阶段是执行类构造器<clinit>()方法的过程，<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，虚拟机中第一个被执行的<clint>()方法的类肯定是java.lang.Object，静态语句块中只能访问到定义在静态语句块之前的变量。同一个类加载器下，一个类型只能被初始化一次。</clint></clinit></clinit></p><h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><p>​     看下下面这段程序，思考下输出会是啥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by yuanqiongqiong on 2019/4/6.</span><br><span class="line"> */</span><br><span class="line">public class StaticTest &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    static StaticTest st = new StaticTest();</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    StaticTest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;3&quot;);</span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void staticFunction()&#123;</span><br><span class="line">        System.out.println(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int a=110;</span><br><span class="line">    static int b =112;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     输出：</p><p><code>23a=110,b=014</code></p><p>​      如果理解了上面讲的类加载过程，这个结果应该很好理解。首先我们看StaticTest的初始化时机，在main方法中调用静态方法staticFunction()，在初始化前会首先进行类的加载过程。经过加载，链接过程后静态变量st=null，b=0。</p><p>​      然后执行初始化阶段，上述的clinit应该包含如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">112</span>;</span><br></pre></td></tr></table></figure><p>​      首先执行构造函数，这个时候会先对成员变量初始化，即设置a=110，然后执行代码块（先于构造函数里语句执行）。这里可能大家会觉得StaticTest类的初始化阶段还没完成就开始执行构造函数初始化实例变量，其实我理解这块并没有问题，因为在连接阶段后Class对象已经在方法区了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     最后执行构造函数的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"3"</span>);</span><br><span class="line">System.out.println(<span class="string">"a="</span>+a+<span class="string">",b="</span>+b);</span><br></pre></td></tr></table></figure><p>​     完成上述初始化阶段后，执行staticFunction函数。以上就是上述代码的执行整体流程，相信大家对输出应该没有异议了。</p><p>​     如果再上述代码里将变量b的类型改为static final，那么b的输出值即为112。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>​      上述类加载过程是由jvm的类加载器完成，java中默认的类加载器有Bootstrap ClassLoader，Extension ClassLoader，App ClassLoader，分别负责的加载不同的类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。所以，hotspot使用双亲委派模型保证一个类只能被加载一次，确立了其在虚拟机中的唯一性。</p><p>1）Bootstrap ClassLoader</p><p>​     启动类加载器，负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar中的class。</p><p>（2）Extension ClassLoader</p><p>​    扩展类加载器，负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar。</p><p>（3）App ClassLoader</p><p>​    系统类加载器，负责加载当前java应用的classpath中的所有类。</p><p>​     双亲委派模型就是一个类收到类加载请求后，它首先不会尝试自己加载这个类，而是把这个请求委派为父类加载器取处理。因此，所有的请求都会送到顶层的启动类加载器中，只有父类无法加载请求，子加载器才会尝试自己去加载。</p><p><img src="/2019/04/06/从java类加载机制解析变量初始化/jvmload2.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《深入理解java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​         java类加载机制对我来说总是熟悉又陌生，之前也单独是进行了解过，但总是当时很明白，过了一段时间这块又忘的差不多了。所以
      
    
    </summary>
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MAT中指标解释</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/05/MAT%E4%B8%AD%E6%8C%87%E6%A0%87%E8%A7%A3%E9%87%8A/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/05/MAT中指标解释/</id>
    <published>2019-04-05T14:46:40.000Z</published>
    <updated>2019-04-05T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>​       在用MAT进行内存快照分析时会看到有两个指标Shallow Heap和Retained Heap，下面给出这两个指标的含义：</p><p>（1）Shallow Heap</p><p>​       中文释义“表面上的堆大小”指的是对象本身占有内存的大小，不包含其引用对象的大小。常规对象该指标是对象的数量和类型的大小决定，数据则由类型的大小和数据的长度决定。</p><p>（2）Retained Heap</p><p>​       中文释义“持有的堆的大小”指的是当该对象被回收时那些将被回收的对象集合多有对象大小叠加的大小（包括其本身大小）。例如有一个ArrayList持有10个对象，每个对象带下是4bytes，其本身的大小是X，那么其Retained Heap则为10 * 4 + X。</p><p>下面给出MAT中相关截图：</p><p><img src="/2019/04/05/MAT中指标解释/mat.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​       在用MAT进行内存快照分析时会看到有两个指标Shallow Heap和Retained Heap，下面给出这两个指标的含义：&lt;/p&gt;
&lt;p&gt;（1）Shallow Heap&lt;/p&gt;
&lt;p&gt;​       中文释义“表面上的堆大小”指的是对象本身占有内存的大小，
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>从String.intern()方法浅谈堆中常量池</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/04/%E4%BB%8EString-intern-%E6%96%B9%E6%B3%95%E6%B5%85%E8%B0%88%E5%A0%86%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/04/从String-intern-方法浅谈堆中常量池/</id>
    <published>2019-04-04T15:27:08.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​       String是我们最常用的一个类，和普通java类一样其对象会存在java堆中。但是String类有其特殊之处，可以通过new方法生成，也可以通过带引号的字符串常量直接赋值。在JDK7之前，字符串常量是存在永久带Perm 区的，JDK7开始在将常量池迁移到堆中，这个变化也导致了String的新特性，下面我们慢慢进行介绍。</p><h1 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h1><p>简单的说，String.intern()方法的作用就是返回常量池中字符串对象，在对该方法进行详解之前，我们看几个创建字符串对象的例子。以下说明及运行结果都是以JDK8为java环境。</p><p>（1）直接赋值字符串常量</p><p>​      这种方式会判断常量池中是否存在字符串常量，如果存在返回该常量对象，否则在常量池中创建常量对象并返回。</p><p><code>//在常量池中创建常量“abc”，s1,s2指向常量池中对象地址        String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//true</code></p><p>（2）通过new关键字创建</p><p>​      这种方式会在堆上创建String对象，如果常量池中没有该常量，将常量加入常量池中。</p><p><code>//在堆上创建对象S3,S4,常量池中创建对象“abc”String s3 = new String(&quot;abc&quot;);String s4 = new String(&quot;abc&quot;);System.out.println(s3 == s4);//false</code></p><p>（3）字符串常量相加</p><p>​       这种方式如s5，会在常量池中创建”cd”,”ef”,”cdef”三个对象，s5指向常量池中的”cdef”对象。</p><p><code>String s5 = &quot;cd&quot; + &quot;ef&quot;;String s6 = &quot;cdef&quot;;System.out.println(s5==s6);//true</code></p><p>（4）两个new的String对象相加</p><p>​      这种方式如s7，会在堆中创建三个对象”gh”对象，”lm”对象，以及”ghlm”对象，在常量池中创建对象”gh”,”lm”。</p><p><code>String s7 = new String(&quot;gh&quot;) + new String(&quot;lm&quot;);String s8 = &quot;ghlm&quot;;System.out.println(s7==s8);//false</code></p><p>（5）字符串常量与new的String对象相加</p><p>​     这种方式如s9，会在堆中创建两个对象“op”，“mnop”，并将字符串常量“op”, “mn”加到常量池中。</p><p><code>String s9 = &quot;mn&quot; + new String(&quot;op&quot;);String s10 = &quot;mnop&quot;;System.out.println(s9==s10);//false</code></p><p>​     了解字符串常量的创建及其在内存中的存储，我们看native方法intern()的作用：判断String对象的常量值是否存在于常量池中，如果存在并且是常量池对象，返回该常量池对象；如果存在并且是指向堆中的对象，返回堆中对象地址；如果不存在，则将对象的引用复制到常量池，并返回该对象的引用。下面我们看几条语句的运行结果，第一个输出之所以为true，</p><p><code>String s11 = new String(&quot;a&quot;) + new String(&quot;a&quot;);s11.intern();//由于常量池中无“aa”,因此在常量池中建“aa”的引用,指向堆中的s11String s12 = &quot;aa&quot;;//s12指向常量池中的对象（该对象指向S11）System.out.println(s11 == s12.intern());//trueString s13 = new String(&quot;b&quot;);s13.intern();//常量池中已经有“b”了，不做任何操作String s14 = &quot;b&quot;;System.out.println(s13==s14.intern());//false</code></p><p>​      如果理解了以上运行的结果，对intern()方法的左右就掌握的差不多了。那么久可以开始我们的主题，string pool，字符串常量池。</p><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>​       字符串常量池是jvm为了减小内存开销而在创建字符串对象时的一个优化，类似缓冲区。在hotspot中，字符串常量池是一个叫做StringTable的HashTable，默认长度是1009，在JDK7开始可以通过”-XX:StringTableSize=1009” 参数来设置，字符串常量池数据可以被gc回收（在JDK6及其以前，字符串常量存在永久带无法被gc回收，如果添加太多字符串常量到该区域，容易发生OOM）。由于字符串常量池是利用HashTable实现，因此一定会发生hash碰撞。jvm在这方面做了一定优化，会根据hashTable的碰撞情况来决定是否做rehash，当从这个StringTable里查找某个字符串是否存在，如果对其对应的桶链表进行遍历，遍历超过了100个节点还是没有找到，那就会设置一个flag，让下次进入到safepoint的时候做一次rehash动作，尽量减少碰撞的发生。当然，在数据量比较大的情况下，这也无法从根本上解决问题，只能设置StringTableSize的值来缓解。</p><p>​       由于JDK7开始字符串常量池在堆中分布，所以young gc过程会扫描该区域，以保证处于新生代的String对象不会被回收掉，因此如果字符串常量区非常庞大会导致young gc过程扫描的时间也会变长。但是，young gc阶段并不会对字符串常量区进行回收，具体回收阶段是在Full gc或者CMS gc阶段（题外话：我觉得full gc这个名字并不是很好，容易理解为对所有区域进行回收，其实full GC是对老年代的STW的gc，full gc的次数是老年代gc的STW次数，时间是老年代STW的总时间）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​       String是我们最常用的一个类，和普通java类一样其对象会存在java堆中。但是String类有其特殊之处，可以通过ne
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>对full gc, cms gc, magor gc的疑问</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/04/gc%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/04/gc定义解析/</id>
    <published>2019-04-04T01:34:54.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​        在日常的学习和问题排查中，我们经常会遇到full gc，cms gc，magor gc这几个概念，而对这几个概念的理解可能会有些偏差。如果单纯从名词解析上来讲，执着的弄清楚这几个概念可能就是在浪费时间。但是，如果可以通过对概念的辨析加深对java垃圾回收的理解，这些时间也是值得的。这里，我将对这几个概念进一步理解，纠正自己以前的错误认知。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h3 id="cms-gc"><a href="#cms-gc" class="headerlink" title="cms gc"></a>cms gc</h3><p>​        cms垃圾回收算法是我们线上使用的老年垃圾回收算法，以其较短的停顿时间而被广泛应用，也是jvm中最重要的一个垃圾回收算法。顾名思义，cms gc就是cms回收算法中的各个步骤，这里既有导致STW的初始标记阶段和最终标记阶段，也有和应用线程并发执行的其他阶段，它们都是cms gc。</p><h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>​        我理解full gc就是针对老年代/metaspace区域（Java8之前为永久带）进行的可以导致STW的gc。这里面有个重要的点，只有导致STW的gc才能成为full gc。以我们对cms 算法的了解，如果cms算法正常运行，会发生两次STW。那么以我们讲的概念这样的cms gc会带到两次full gc，下面我们通过jstate命令以及gc日志中cms gc发生的次数来验证这个问题。以我们线上一台机器为例：我们看下统计full gc的数量如下，看出发生了4次full gc。</p><p><img src="/2019/04/04/gc定义解析/gc4.png" alt="gc4"></p><p>​       我们看gc日志看到full 2是最大的cms数量，也就是发生两次cms gc，如上面我们的计算相符。具体如下图：</p><p><img src="/2019/04/04/gc定义解析/gc5.png" alt="gc5"></p><p>​         所以可以这样说，cms中的STW的阶段属于full gc，其他阶段不属于full gc。</p><p>​        正常的full的时间不会很长，如上面的平均时间是0.718/4=0.1795s，但是异常情况下，如如果发生了promotion failed，或者concurrent model failure现象，STW的时间就会很长。这两种情况下的gc并不是由gc线程来执行的，<strong>而是由vm thread 执行的</strong>，整个过程都会STW。先说promotion failed，这是由于在年轻带发生young gc时，eden区晋升的对象，在survivor中发不下，导致年轻带放弃young gc而直接由vm 线程触发一次老年代的gc，这个过程只有单线程执行，完全的STW，因此时间比较长。下面我们看一个promotion failed的例子，我们看到发生了9次full gc。</p><p><img src="/2019/04/04/gc定义解析/gc6.png" alt></p><p>​        查看gc日志，我们看到第五次cms gc是promotion failed引起的且时间用了3.84s，我们计算full gc的次数为4次正常的cms gc带来的8次full gc 加 一次vm thread触发的full gc，一共9次。</p><p><img src="/2019/04/04/gc定义解析/gc7.png" alt></p><p>​        说完promotion failed，我们要说一下concurrent model failure，如果cms gc在执行过程中vm 线程触发了一次full gc，那么这个时候就会产生concurrent model failure，这个时候问题会更加严重，垃圾回收算法会退化为Serail Old，单线程执行，切完全的STW。其实，这里讲的vm 线程触发的full gc和正常的cms gc的实现都在concurrentMarkSweepGeneration.cpp，只不过有着不同的执行路径，vm线程触发的full gc又被称为The background collector，而正常的cms算法被称为The foreground collector。从英文名字中可以清晰的明白前者是后台触发的，而后者是由相应线程主动触发的。</p><h3 id="magor-gc"><a href="#magor-gc" class="headerlink" title="magor gc"></a>magor gc</h3><p>​       我理解的magor gc就是full gc，他们是同一个概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;​        在日常的学习和问题排查中，我们经常会遇到full gc，cms gc，magor gc这几个概念，而对这几个概念的理解可能
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>从gc日志学习gc相关知识</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/03/gc%E6%97%A5%E5%BF%97/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/03/gc日志/</id>
    <published>2019-04-03T11:45:10.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​       最近又对gc有了很大的兴趣，重新对之前gc相关的知识进行学习，其实是看了寒泉子大神gc相关的博客，觉得真的是厉害，这里先记录下如何去阅读gc日志吧。</p><h1 id="gc日志解读"><a href="#gc日志解读" class="headerlink" title="gc日志解读"></a>gc日志解读</h1><h2 id="young-gc-日志"><a href="#young-gc-日志" class="headerlink" title="young gc 日志"></a>young gc 日志</h2><p>我们通过具体的日志进行讲解，如下：</p><p><img src="https://i.bmp.ovh/imgs/2019/04/a6e1021877073145.png" alt>)</p><p>最前面的”Allocation Failure”表示young gc原因，ParNew表示年轻代使用串行多线程垃圾回收器。</p><p>1.表示年轻代垃圾回收期使用的是ParNew;</p><p>2.年轻代回收前使用的大小是81920K;</p><p>3.年轻代回收后使用大小是9566K，可以推断出回收对象大小是81920k-9566k=72354k；</p><p><img src="https://i.bmp.ovh/imgs/2019/04/0f71ecb09d7b9255.png" alt></p><p>5.年轻带垃圾回收的时间；</p><p>6.回收前整个堆的使用大小；</p><p>7.回收后整个堆的使用大小；</p><p>9.这个堆内存回收使用的时间；</p><p>10.指的是gc线程在用户态的时间，如果是多线程的gc算法，该时间是叠加了多线程的时间；</p><p>11.指的是gc线程在内核态的时间，如果是多线程的gc算法，该时间是叠加了多线程的时间；</p><p>12.指的是gc操作从开始到结束的墙钟时间，包括各种非运算的耗时，例如等待磁盘IO，等待线程阻塞，而CPU事件不包括这些事件。我理解这块时间就是gc操作从开始到结束的全部时间。应用程序暂停的时间，对于使用串行垃圾收集时real 大致等于 sys + user; 如下图是使用serial串行垃圾回收算法各部分时间（real 大致等于 sys + user，个人感觉是舍入规则导致不完全相等）。</p><p><img src="https://i.bmp.ovh/imgs/2019/04/212f99d94fc26190.png" alt></p><h2 id="full-gc-（CMS）日志"><a href="#full-gc-（CMS）日志" class="headerlink" title="full gc （CMS）日志"></a>full gc （CMS）日志</h2><p>CMS是老年代垃圾回收算法，由于其避免了长时间的停顿被广泛应用，我们线上老年代都使用的这种算法。下面进行相关讲解：</p><ul><li>阶段一：初始标记（CMS Initial Mark）</li></ul><p>该阶段应用线程会进行一次STW，是CMS算法中两次STW之一，主要工作是：标记GC ROOTS 可达大老年代对象，标记年轻带对象引用的老年代对象。该阶段不会对间接引用对象进行关联，因此该阶段很快。</p><ul><li>阶段二：并发标记（CMS-concurrent-mark）</li></ul><p>该阶段会通过对阶段一标记出的老年带对象进行递归标记，标记处可达的所有对象。该阶段与应用线程是并发执行，因此会出现阶段一种标记的对象引用发生变化，或年轻带对象晋升到老年带，或对象直接分配到老年等情况，在该阶段也会把这些对象所在的Card标记为Dirty，以便在下个阶段处理。</p><ul><li>阶段三：并发预清理（CMS-concurrent-preclean）</li></ul><p>该阶段主要做两件事，一个是处理在并发标记阶段标记的Dirty Card中对象，重新标记引用发生变化的对象；另一个是在并发标记阶段会出现新生代新对象引用老年代对象，这个阶段需要标记这些对象。该阶段和应用线程是并发执行的，可以通过参数CMSPrecleaningEnabled关闭该对象。</p><ul><li>阶段四：可中断预清理（CMS-concurrent-abortable-preclean）</li></ul><p>由于在重新标记阶段会进行CMS中另一次STW，对老年代活跃对象进行重新标记，因此为了减小重新标记阶段阶段STW的时间，在重新标记阶段之前加入该过程进行一定的清理工作。该阶段发生的条件是eden区内存使用量大于CMSScheduleRemarkEdenSizeThreshold，默认是2M。因此该阶段主要工作一个是处理Dirty Card中的对象；另一个是处理年轻带对象，标记活跃的老年代对象。该阶段和应用线程并发进行，会循环执行下去，直到时间达到CMSMaxAbortablePrecleanTime（默认5s）或者次数达到CMSMaxAbortablePrecleanLoops（默认无限制）或者eden区使用率达到CMSScheduleRemarkEdenPenetration（默认50%）。可以知道，该阶段会扫描年轻带对象，如果再该阶段之前进行一次young gc 减小年轻带活跃对象数目，会加快该阶段速度，可以通过参数CMSScavengeBeforeRemark来控制。</p><ul><li>阶段五：重新标记（CMS Final Remark）</li></ul><p>如上所述，该阶段是CMS中另一个STW阶段，需要尽可能的减小该阶段时间，上面的阶段三，阶段四的存在正式为了这一点。该阶段的工作一个是遍历GC ROOTS 进行重新标记，一个是遍历新生代对象重新标记，另一个是遍历Dirty Card重新标记。</p><ul><li>阶段六：清理阶段（CMS-concurrent-sweep）</li></ul><p>该阶段会清理不活跃的老年代对象，该阶段与应用线程并发进行。</p><ul><li>阶段七：重置阶段</li></ul><p>该阶段会重置CMS算法相关的数据结构，为下次gc做准备，该阶段与应用线程并发执行。</p><p>老年代gc回收的相关日志如下，这里不进行解读，容量，时间相关参数和年轻大大致类似。</p><p><code>1.803: [CMS-concurrent-mark-start]1.957: [GC (Allocation Failure) 1.958: [ParNew: 92159K-&gt;10239K(92160K), 0.1382680 secs] 565579K-&gt;565578K(1038336K), 0.1383043 secs] [Times: user=0.81 sys=0.05, real=0.14 secs] 2.163: [GC (Allocation Failure) 2.163: [ParNew: 92159K-&gt;10239K(92160K), 0.1259734 secs] 647498K-&gt;647496K(1038336K), 0.1260101 secs] [Times: user=0.70 sys=0.04, real=0.12 secs] 2157ms2.671: [CMS-concurrent-mark: 0.603/0.867 secs] [Times: user=2.77 sys=0.10, real=0.86 secs] 2.671: [CMS-concurrent-preclean-start]2.842: [CMS-concurrent-preclean: 0.172/0.172 secs] [Times: user=0.17 sys=0.00, real=0.18 secs] 2.842: [CMS-concurrent-abortable-preclean-start] CMS: abort preclean due to time 7.996: [CMS-concurrent-abortable-preclean: 2.430/5.153 secs] [Times: user=2.41 sys=0.01, real=5.15 secs] 7.996: [GC (CMS Final Remark) [YG occupancy: 28252 K (92160 K)]7.996: [Rescan (parallel) , 0.0047059 secs]8.001: [weak refs processing, 0.0000344 secs]8.001: [class unloading, 0.0002629 secs]8.001: [scrub symbol table, 0.0005571 secs]8.002: [scrub string table, 0.0001773 secs][1 CMS-remark: 637257K(946176K)] 665509K(1038336K), 0.0058199 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] 8.002: [CMS-concurrent-sweep-start]8.353: [CMS-concurrent-sweep: 0.351/0.351 secs] [Times: user=0.35 sys=0.00, real=0.35 secs] 8.353: [CMS-concurrent-reset-start]8.356: [CMS-concurrent-reset: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></p><p>full gc是我们比较担心的事情，因为会出现较长的STW，那么什么情况下会触发full gc呢，下面我列出几种情况：</p><ul><li>老年代使用率达到阈值 CMSInitiatingOccupancyFraction（该值默认是92%）；</li><li>新生代晋升担保失败，也就是由于新生代survivor区域大小无法容纳eden区存活的对象，直接晋升到老年代，老年代没有足够空间，需要进行一次full gc。</li><li>代码执行System.gc()并且没有参数ExplicitGCInvokesConcurrent，也会触发full gc；</li><li>jdk1.7及之前还存在永久代时，在开启 CMSClassUnloadingEnabled时，如果永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction（该值默认是92%）。在jdk1.8及以后永久代被metaspace替代，metaspace区域也是使用cms进行垃圾回收，可以设置该区域发生gc的初始阈值的MetaspaceSize，但是该阈值会一直变化，对该区域参数的相关介绍可以参考<a href="https://mp.weixin.qq.com/s/SsXbRvtvawKDHstFpU4uog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SsXbRvtvawKDHstFpU4uog</a> 。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​       最近又对gc有了很大的兴趣，重新对之前gc相关的知识进行学习，其实是看了寒泉子大神gc相关的博客，觉得真的是厉害，这里先记录
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
  </entry>
  
</feed>
