<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>袁琼琼的博客</title>
  
  <subtitle>一个想在技术道路走下去的小渣渣，多多关照！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yuanqiongqiong.cn/"/>
  <updated>2019-04-11T15:16:16.000Z</updated>
  <id>https://www.yuanqiongqiong.cn/</id>
  
  <author>
    <name>袁琼琼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis中使用动态代理机制分析</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/11/MyBatis%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/11/MyBatis中使用动态代理机制分析/</id>
    <published>2019-04-11T15:09:23.000Z</published>
    <updated>2019-04-11T15:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​       近期，对mybatis源码进行了一段粗略的学习，对之前一些不太理解的问题也有了进一步的理解。其中就包括动态代理机制在mybatis中的使用，这篇文章主要对这一点进行分析，以便在日后遗忘的时候可以看一看。</p><h1 id="MyBatis中动态代理"><a href="#MyBatis中动态代理" class="headerlink" title="MyBatis中动态代理"></a>MyBatis中动态代理</h1><p>​       我们都知道Spring中AOP机制就是通过java的动态代理实现的，个人理解动态代理就是一种代理模式的实现，只不过动态代理中的代理类是在运行期生成的(也可以通过该点来区分静态代理和动态代理，静态代理是代理类在编译器就生成了)。java通过Proxy类和InvocationHandler接口方便的实现了动态代理。这里我们不进行动态代理分析，先看看mybatis中如何使用了动态代理，先上一段简单的mybatis实现数据库访问的代码，有一个数据表User记录用户的id,userName,userAge三个属性，其中userMapper.xml文件如下：</p><p><strong>mapper.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!-- 定义操作user表的sql映射文件userMapper.xml  --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.qiongqiong.bean.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;selectUserByID&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from `user` where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>​        接口UserMapper定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yuanqiongqiong on 2018/5/13.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">selectUserByID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       当我们使用调用selectUserByID时会使用如下的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory;</span><br><span class="line">Reader reader;</span><br><span class="line">String resource = <span class="string">"configuration.xml"</span>;</span><br><span class="line">reader= Resources.getResourceAsReader(resource);</span><br><span class="line">sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = (User) userMapper.selectUserByID(<span class="number">1</span>);</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p>​        通过这种方式我们就完成了对数据库的访问操作。但是，大家一定会有疑问，我们没有实现UserMapper接口，userMapper.selectUserByID(1)方法是如何执行的。没错，是java的动态代理，mybatis使用了动态代理机制为UserMapper生成了一个代理类，为了清楚的认识到代理类的实现，我将该代理类的字节码打印到文件中，并在IDEA下进行反编译如下。userMapperProxy类实现了代理类和UserMapper接口。</p><p><strong>UserMapperImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">userMapperProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">userMapperProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List <span class="title">selectUserByID</span><span class="params">(<span class="keyword">int</span> var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (List)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;Integer.valueOf(var1)&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.qiongqiong.bean.UserMapper"</span>).getMethod(<span class="string">"selectUserByID"</span>, <span class="keyword">new</span> Class[]&#123;Integer.TYPE&#125;);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         如普通的动态代理一致，当调用selectUserByID方法时会调用InvocationHandler中的invoke方法，去调用相应的实现方法。我们继续看一下userMapperProxy中的InvocationHandler的实现类MapperProxy，从invoke方法代码中我看出如果调用方法是接口中定义的数据库操作方法，那么执行如下逻辑：MapperMethod mapperMethod = this.cachedMapperMethod(method); return mapperMethod.execute(this.sqlSession, args); 看到这两行代码我们终于明白sql的具体执行，最终还是通过sqlSession来执行。MapperMethod封装了xml具体的sql语句，其实这个执行活动类似 User user =(User) session.selectOne(“selectUserByID”, 1);  这条语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles.Lookup;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.lang.UsesJava7;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.ExceptionUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">        <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isDefaultMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.invokeDefaultMethod(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span>(mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UsesJava</span>7</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Constructor&lt;Lookup&gt; constructor = Lookup.class.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;Class.class, Integer.TYPE&#125;);</span><br><span class="line">        <span class="keyword">if</span>(!constructor.isAccessible()) &#123;</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">        <span class="keyword">return</span> ((Lookup)constructor.newInstance(<span class="keyword">new</span> Object[]&#123;declaringClass, Integer.valueOf(<span class="number">2</span>)&#125;)).unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (method.getModifiers() &amp; <span class="number">1033</span>) == <span class="number">1</span> &amp;&amp; method.getDeclaringClass().isInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​       近期，对mybatis源码进行了一段粗略的学习，对之前一些不太理解的问题也有了进一步的理解。其中就包括动态代理机制在myba
      
    
    </summary>
    
      <category term="数据库" scheme="https://www.yuanqiongqiong.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="mybatis" scheme="https://www.yuanqiongqiong.cn/tags/mybatis/"/>
    
      <category term="数据库" scheme="https://www.yuanqiongqiong.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ThreadPoolExecutor的实现</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/10/%E8%B0%88%E8%B0%88ThreadPoolExecutor%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/10/谈谈ThreadPoolExecutor的实现/</id>
    <published>2019-04-10T02:40:40.000Z</published>
    <updated>2019-04-12T03:18:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​      线程作为系统稀缺资源，如果在应用中进行频繁的创建和销毁，会为我们的应用带来灾难性的体验，增大系统负荷，降低效率。池化技术为该问题的解决提供了一种有效的思路，通过建立一个线程池，每次线程的时候从池中取出一个空闲的线程，这样就省去了线程创建和销毁。java的线程池实现是在jdk1.5开始引入的，本文将对其中最常用的ThreadPoolExecutor的实现进行详细的介绍，系统可以通过本文了解到如何去实现一个线程池，并向Doug Lea大神致敬。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>​       我们先看下面的线程池使用的例子，在该例子中我声明一个核心线程数是2，最大线程数是5，非核心线程线程存活时间1s，阻塞队列大小为1，拒绝策略为AbortPolicy，我们会输出程序执行过程中的线程池达到的最大线程数以及在所有任务执行结束后线程池中线程的数量。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yuanqiongqiong on 2019/4/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ThreadPoolExecutorTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">7</span>;i++) &#123;</span><br><span class="line">            String runnableName = <span class="string">"test"</span> + i;</span><br><span class="line">            PersonRunnable personRunnable = <span class="keyword">new</span> PersonRunnable(runnableName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                threadPoolExecutor.execute(personRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"执行&#123;&#125;任务异常"</span>, runnableName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            LOGGER.info(<span class="string">"线程池当前线程数目 = &#123;&#125;"</span>, threadPoolExecutor.getPoolSize());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">"线程池中达到的最大线程数目 = &#123;&#125;"</span>, threadPoolExecutor.getLargestPoolSize());</span><br><span class="line">        LOGGER.info(<span class="string">"线程池当前线程数目 = &#123;&#125;"</span>, threadPoolExecutor.getPoolSize());</span><br><span class="line">        LOGGER.info(<span class="string">"线程池已经完成的任务数量 = &#123;&#125;"</span>, threadPoolExecutor.getCompletedTaskCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PersonRunnable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LOGGER.info(<span class="string">"我是"</span> + name + <span class="string">"我在线程"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"任务&#123;&#125;执行异常"</span>, Thread.currentThread().getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">20:22:26.571 [pool-1-thread-3] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test3我在线程pool-1-thread-3</span><br><span class="line">20:22:26.571 [pool-1-thread-2] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test1我在线程pool-1-thread-2</span><br><span class="line">20:22:26.571 [pool-1-thread-4] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test4我在线程pool-1-thread-4</span><br><span class="line">20:22:26.571 [pool-1-thread-5] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test5我在线程pool-1-thread-5</span><br><span class="line">20:22:26.571 [pool-1-thread-1] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test0我在线程pool-1-thread-1</span><br><span class="line">20:22:26.576 [main] ERROR com.meituan.campaign.ThreadPoolExecutorTest - 执行test6任务异常</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task com.meituan.campaign.ThreadPoolExecutorTest$PersonRunnable@46f7f36a rejected from java.util.concurrent.ThreadPoolExecutor@421faab1[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</span><br><span class="line">at com.meituan.campaign.ThreadPoolExecutorTest.main(ThreadPoolExecutorTest.java:30)</span><br><span class="line">20:22:26.681 [pool-1-thread-5] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test2我在线程pool-1-thread-5</span><br><span class="line">20:22:27.082 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池当前线程数目 = 5</span><br><span class="line">20:22:29.084 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池中达到的最大线程数目 = 5</span><br><span class="line">20:22:29.084 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池当前线程数目 = 2</span><br><span class="line">20:22:29.085 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池已经完成的任务数量 = 6</span><br></pre></td></tr></table></figure><p>​        由于我们代码设置了最大线程数是5个，并且阻塞队列大小是1，所以同一时间最多会有6个任务被执行，其中1个任务放在阻塞队列中。线程池达到的最大线程数目是5个，因为线程池设置了maximumPoolSize=5。非核心线程会在1s空闲后被回收，因此最终线程池线程数目还是2个。</p><h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>​        抛开ThreadPoolExecutor，我们先想下实现一个线程池需要哪些成员变量，个人感觉以下变量是必不可少的：(1) 一个存放线程的容器或数组；(2) 一个队列用来在线程池线程不足是存放排队的任务；(3) 一个状态字段表示线程池的状态，用来表示线程池不同生命周期状态。下面，我们看下ThreadPoolExecutor的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示线程状态和线程数，高三位代表线程状态，低29位代表线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//值为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//线程池最大线程数，大概为5亿，可以肯定不会达到这么多线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程池处于运行状态可以接收新任务并执行任务队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//该状态下线程池不再接收新任务，但是会把任务队列中的任务执行完成，调用shutDown()会进入该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//该状态下线程池不接受新任务并抛弃任务队列中的任务中断所有正在执行的线程，调用shutDownNoW()会进入该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//已经没有任务可以执行，会从SHUTDOWN和STOP状态变换为该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//在执行完terminated()操作后会进入该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//任务阻塞队列，存放排队任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//存放线程的hashset</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//线程工厂，生成新线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//线程池核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//线程池最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><p>​         上述代码的注释给出了线程池各个状态的含义，我们看下各个状态之间的状态转换关系，具体如下：</p><p>(1) RUNNING -&gt; SHUTDOWN：调用了shutdown()函数；</p><p>(2) (RUNNING or SHUTDOWN) -&gt; STOP：调用了shutdownNow()；</p><p>(3)SHUTDOWN -&gt; TIDYING：当线程池线程为空并者任务队列为空；</p><p>(4)STOP -&gt; TIDYING：当线程池线程为空；</p><p>(5)TIDYING -&gt; TERMINATED：当调用了terminated()方法；</p><p>​       如上示例，我们把一个任务放入线程池的execute()函数中，线程池会为我们选择一个线程来执行我们提交的任务。在这个选择线程的过程中，如果线程池中线程数量小于corePoolSize，那么将创建新线程执行任务；当线程池数量大于等于corePoolSize并且小于maximumPoolSize，线程池会把任务放到阻塞队列workQueue中直到workQueue满了去创建新线程；当线程池线程数量等于maximumPoolSize并且workQueue满时会执行拒绝策略。下面我们通过execute()函数的逻辑来理解上述过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//如果线程数小于核心线程数，那么创建一个新的线程来执行任务command</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果线程数大于等于核心线程数，线程数处于RUNNING状态(可以将任务加入阻塞队列)并且加入阻塞队列成功(即阻塞队列未满)，那么任务就被加入阻塞队列等待空闲线程。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//再次检查线程池状态，如果不是RUNNING状态，从阻塞队列中移除任务，执行拒绝策略</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//线程处RUNNING状态并且线程数是0，则创建个空闲新线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果线程数大于核心线程并且阻塞队列已满，则以maximumPoolSize为线程数最大值进行处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            <span class="comment">//线程池中线程达到最大线程数并且阻塞队列已经满执行拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​       看到上面的代码逻辑，我们会发现主要的逻辑还是在addWorker里，这个函数主要功能就是为任务分配线程并执行，我们在看这块逻辑之前需要取看一个重要的Worker类。该类封装了线程及任务，可以在内部执行任务，具体定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">    <span class="comment">//具体线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//线程要执行的任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//线程完成的任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//调用线程工厂创建新的线程，threadFactory由我们的线程池构造函数传入，没有指定则使用默认的，这块会创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以看出Worker实现了AQS，其本身也是不可重入锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      思考为什么Worker要继承AQS实现一个独占锁？这个问题我们后面分析。</p><p>​     了解了worker的构成，我们就可以具体看下addWorker函数的执行逻辑了，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core为true，那么创建线程是以corePoolSize作为线程数最大值，否则以maximumPoolSize作为线程数最大值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 线程状态是非RUNNING状态不再进行任务提交处理，其中SHUTDOWN状态下已经提交进行任务和阻塞队列         中的任务要继续处理</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">//线程池中线程大于最大线程数或者大于要求的阈值，返回失败</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//符合要求后，CAS增大线程数，跳出自旋，走下面的线程创建逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;<span class="comment">//标记线程是否启动</span></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;<span class="comment">//标记线程是否添加成功</span></span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建新的线程并封装为一个Work对象</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                    <span class="comment">//对线程池创建的线程状态进行检查</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">//如果新线程检查成功，将新线程加入workers中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            <span class="comment">//更新全局变量，线程池达到的最大线程数，该值可以输出作为线程池参数设定的指标</span></span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">//这块重要了，线程创建成功后，开始执行任务</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​       我们继续跟着上述代码思路走，看下任务如何执行，t.start()的会调用Worker类run()方法，而该方法会调用runWorker来从任务队列中获取任务，执行任务，具体看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果Worker中创建时存在任务，则执行；否则，调用getTask从阻塞队列中获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 上面的英文注释很清楚了，这块为了处理调用shutdownNow时需要停止所有的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这个函数可以自己实现，默认为空</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行具体任务的业务逻辑</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//这个函数可以自己实现，默认为空</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//执行线程销毁过程</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Worker线程在从主阻塞队列中获取任务时会一直循环的获取，除非线程池状态变为非RUNNING或者阻塞队列为空的情况下线程池线程数大于核心线程数，这个时候会返回执行上面的额线程销毁过程processWorkerExit。看下具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            // 线程池状态为STOP或者（状态为SHUTDOWN&amp;&amp;任务队列为空），这个时候无需在执行任务</span><br><span class="line">            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            //设置了允许核心线程超过keepAliveTime空闲后销毁线程 或者 线程数大于核心线程数</span><br><span class="line">            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            </span><br><span class="line">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">                if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    return null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">               //从阻塞队列中获取任务，如果进行超时控制，则调用poll方法，否则调用take一直阻塞到队列中有任务</span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                if (r != null)</span><br><span class="line">                    return r;</span><br><span class="line">                timedOut = true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        以上就是线程池中任务执行的大致过程，接下来我们对线程池结束及其中实现的一些细节进行分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​      线程作为系统稀缺资源，如果在应用中进行频繁的创建和销毁，会为我们的应用带来灾难性的体验，增大系统负荷，降低效率。池化技术为该问
      
    
    </summary>
    
      <category term="java多线程" scheme="https://www.yuanqiongqiong.cn/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="多线程" scheme="https://www.yuanqiongqiong.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://www.yuanqiongqiong.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈FutureTask的实现</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/08/%E8%B0%88%E8%B0%88FutureTask%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/08/谈谈FutureTask的实现/</id>
    <published>2019-04-08T14:40:19.000Z</published>
    <updated>2019-04-09T05:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​       在使用java多线程解决问题的时候，为了提高效率，我们常常会异步处理一些计算任务并在最后异步的获取计算结果，这个过程的实现离不开Future接口及其实现类FutureTask。FutureTask类实现了Runnable, Future接口，接下来我会通过源码对该类的实现进行详解。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>​       我们先看下FutureTask中的主要方法如下，可以看出FutureTask实现了任务及异步结果的集合功能。看到这块的方法，大家肯定会有疑问，Runnable任务的run方法返回空，FutureTask如何依靠该方法获取线程异步执行结果，这个问题，我们在下面给大家介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下五个方法实现接口Future中方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;           </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//实现接口Runnable中方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>​        我们在使用中会构造一个FutureTask对象，然后将FutureTask扔到另一个线程中执行，而主线程继续执行其他业务逻辑，一段时间后主线程调用FutureTask的get方法获取执行结果。下面我们看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yuanqiongqiong on 2019/4/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        Callable callable = <span class="keyword">new</span> AccCallable(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">        executorService.execute(futureTask);</span><br><span class="line">        System.out.println(<span class="string">"go to do other things in main thread"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"go back in main thread"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = (<span class="keyword">int</span>) futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"result is "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AccCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AccCallable</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"acc a and b in threadId = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><code>go to do other things in main threadacc a and b in threadId = pool-1-thread-1go back in main threadresult is 3</code></p><h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>​        在分析实现前，我们先想下如果让我们实现一个类似FutureTask的功能，我们会如何做？因为需要获取执行结果，需要一个Object对象来存执行结果。任务执行时间不可控性，我们需要一个变量表示执行状态。其他线程会调用get方法获取结果，在没达到超时的时候需要将线程阻塞或挂起。因此需要一个队列类似的结构存储等待该结果的线程信息，这样在任务执行线程完成后就可以唤醒这些阻塞或挂起的线程，得到结果。FutureTask的实际实现也是类似的逻辑，具体如下。</p><p>​        首先看下FutureTask的主要成员变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//futureTask执行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//具体的执行任务，会在run方法中抵用callable.call()</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"><span class="comment">//获取结果的等待线程节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><p>​         对于执行状态，在源码中已经有了非常清晰的解释，这里我只是贴出源码，不在进行说明，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Possible state transitions:</span><br><span class="line">  * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">  * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">  * NEW -&gt; CANCELLED</span><br><span class="line">  * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line">  */</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br></pre></td></tr></table></figure><p>​         然后我们看下FutureTask的构造函数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造函数传入runnable对象时调用静态工具类Executors的方法转换为一个callable对象</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如前所述，FutureTask的执行线程中会调用其run()方法执行任务，我们看下这块逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.如果执行状态不是NEW或者有其他线程执行该任务，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">//2.如果执行状态是NEW,即任务还没执行，直接调用callable.call()方法获取执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//3.发生异常，更新status为EXCEPTIONAL，唤醒挂起线程</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4.如果结果成功返回，调用set方法将设置outcome，更改status执行状态，唤醒挂起线程</span></span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​     我们看下set函数的实现，具体看下4中的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//将执行状态变更为COMPLETING</span></span><br><span class="line">       <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">           <span class="comment">//设置执行结果</span></span><br><span class="line">           outcome = v;</span><br><span class="line">           <span class="comment">//设置执行状态为NORMAL</span></span><br><span class="line">           UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">           <span class="comment">//执行完成后处理操作，具体就是遍历阻塞链表，删除链表节点，并唤醒每个节点关联的线程</span></span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​       以上就是任务执行线程做的逻辑，以上逻辑也回答了FutureTask如何得到执行结果的疑问。下面我们看下用户调用get方法获取执行结果时的实现逻辑，这个时候FutureTask可能处理各种状态，即可能没有执行，执行中，已完成，发生异常等，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//执行状态是NEW或者COMPLETING时执行awaitDone将线程加入等待队列中并挂起线程</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="comment">//根据执行状态status进行结果封装</span></span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我理解这块是get的核心逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//如果设置了超时时间，计算还有多长时间超时</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//如果当前线程被中断，删除等待队列中的节点，并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">//如果执行状态已经完成或者发生异常，直接跳出自旋返回</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果执行状态是正在执行，说明线程已经被加入到等待队列中，放弃cpu进入下次循环(真正的自旋)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="comment">//第一次进入循环，创建节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="comment">//将节点加入到等待队列中，waiters相当于头阶段，不断将头结点更新为新节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="comment">//如果设置了超时时间，在进行下次循环前查看是否已经超时，如果超时删除该节点进行返回</span></span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//挂起当前节点</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​       这里需要说明一点，FutureTask中的阻塞队列新加入的节点都在头结点并且next指向之前的头结点，waitars指针总是指向新加入节点，通过waitars可以遍历整个等待队列，具体截图如下。此外等待队列节点结构很简单成员变量只有线程引用和next指针，这里再列出器接口。</p><p><img src="/2019/04/08/谈谈FutureTask的实现/futureTask等待队列.png" alt></p><p>​        读到这里，相信大家已经对FutureTask的实现细节有了一定的认识。此外，FutureTask没有使用锁而是使用Unsafe的是CAS的原子操作来解决竞争问题，减少了锁带来的上下文切换的开销，提高了效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​       在使用java多线程解决问题的时候，为了提高效率，我们常常会异步处理一些计算任务并在最后异步的获取计算结果，这个过程的实现离
      
    
    </summary>
    
      <category term="java多线程" scheme="https://www.yuanqiongqiong.cn/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="多线程" scheme="https://www.yuanqiongqiong.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://www.yuanqiongqiong.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从java类加载机制解析变量初始化</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/06/%E4%BB%8Ejava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/06/从java类加载机制解析变量初始化/</id>
    <published>2019-04-06T02:41:41.000Z</published>
    <updated>2019-04-06T06:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​         java类加载机制对我来说总是熟悉又陌生，之前也单独是进行了解过，但总是当时很明白，过了一段时间这块又忘的差不多了。所以，想通过这篇文章对这块知识进行详细的总结。</p><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><p>​        我们知道java代码是运行在jvm上的，这个过程需要经过将源代码编译为class字节码，然后将字节码装载到jvm中行程其可以使用的java类型，这个装载的过程就是java类的加载机制。Java类加载过程可以分为加载，验证，准备，解析，初始化五个阶段，其中验证，准备，解析三个阶段又可以称为连接过程。可以看出，java的连接工作发生在运行期，这为程序提供了高度的灵活性(java 动态扩展特性依赖于此)。下面，我们先看下结合java加载机制后的类对象声明周期图示，然后对相关阶段进行详细介绍。</p><p><img src="/2019/04/06/从java类加载机制解析变量初始化/jvmload.png" alt></p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>​        jvm并没有对类的加载时机进行明确的规范，但是却对类的初始化时机进行了严格的规定（在进行初始化的时候，加载，验证，准备，解析必须完成）。jvm规定必须在“initialize on first active use”是对类进行初始化，即首次使用时必须对类进行初始化。以下几种情况会触发类的初始化过程：</p><p>（1）创建一个类的实例时，new、反射、克隆或反序列化；</p><p>（2）调用某个类的静态方法时；</p><p>（3）使用某个类或接口的静态字段或对该字段赋值时（final字段除外）；</p><p>（4）调用Java的某些反射方法时；</p><p>（5）初始化某个类的子类时；</p><p>（6）在虚拟机启动时某个含有main()方法的那个启动类。</p><p>​         需要注意的是：（1）同一个类在同一个类加载器下只能初始化一次；（2）引用在编译期就能确定的静态常量不会触发初始化；（3）在初始化前必须进行加载和链接；（4）如果这个类有父类并且这个父类没有被初始化,则先初始化父类。</p><h2 id="各阶段介绍"><a href="#各阶段介绍" class="headerlink" title="各阶段介绍"></a>各阶段介绍</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>​     在该阶段，jvm需要完成以下3件事：</p><p>（1）通过一个类的全限定名来获取定义此类的二进制字节流，这个字节流可以来自class文件，网络io，或者动态生成（即动态代理技术的基础）；</p><p>（2）<strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</strong></p><p>（3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。（对于hotspot，Class对象比较特殊，存在于方法区）。</p><p>​     需要说明的是对于数组类而言，本身不通过类加载器创建，它是由java虚拟机直接创建的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​      该阶段是为了保证加载的Class文件符合虚拟机的要求，不会危及虚拟机自身的安全，主要有一下四个检验阶段：</p><p>（1）文件格式验证<br>主要验证字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。<br>（2）元数据验证<br>是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范要求。<br>（3）字节码验证<br>主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。<br>（4）符号引用验证<br>     发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析中。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>​      该阶段正式为类变量分配内存并进行初始化，注意是类变量而不是实例变量，该阶段内存分配发生在方法区。<strong>在该阶段完成后类变量会被置为默认值（final类型的静态变量除外）。</strong></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>​      该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。需要对符号引用和常量引用进行说明如下：</p><p>（1）符号引用</p><p>​      符号引用以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</p><p>（2）直接引用</p><p>​     直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位目标的句柄，它是与虚拟机的内存布局相关的，如果有了直接引用，那引用的目标必定已经存在于内存中。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​      该阶段才真正开始执行类定义中的java程序代码，初始化阶段是执行类构造器<clinit>()方法的过程，<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，虚拟机中第一个被执行的<clint>()方法的类肯定是java.lang.Object，静态语句块中只能访问到定义在静态语句块之前的变量。同一个类加载器下，一个类型只能被初始化一次。</clint></clinit></clinit></p><h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><p>​     看下下面这段程序，思考下输出会是啥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by yuanqiongqiong on 2019/4/6.</span><br><span class="line"> */</span><br><span class="line">public class StaticTest &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    static StaticTest st = new StaticTest();</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    StaticTest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;3&quot;);</span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void staticFunction()&#123;</span><br><span class="line">        System.out.println(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int a=110;</span><br><span class="line">    static int b =112;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     输出：</p><p><code>23a=110,b=014</code></p><p>​      如果理解了上面讲的类加载过程，这个结果应该很好理解。首先我们看StaticTest的初始化时机，在main方法中调用静态方法staticFunction()，在初始化前会首先进行类的加载过程。经过加载，链接过程后静态变量st=null，b=0。</p><p>​      然后执行初始化阶段，上述的clinit应该包含如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">112</span>;</span><br></pre></td></tr></table></figure><p>​      首先执行构造函数，这个时候会先对成员变量初始化，即设置a=110，然后执行代码块（先于构造函数里语句执行）。这里可能大家会觉得StaticTest类的初始化阶段还没完成就开始执行构造函数初始化实例变量，其实我理解这块并没有问题，因为在连接阶段后Class对象已经在方法区了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     最后执行构造函数的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"3"</span>);</span><br><span class="line">System.out.println(<span class="string">"a="</span>+a+<span class="string">",b="</span>+b);</span><br></pre></td></tr></table></figure><p>​     完成上述初始化阶段后，执行staticFunction函数。以上就是上述代码的执行整体流程，相信大家对输出应该没有异议了。</p><p>​     如果再上述代码里将变量b的类型改为static final，那么b的输出值即为112。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>​      上述类加载过程是由jvm的类加载器完成，java中默认的类加载器有Bootstrap ClassLoader，Extension ClassLoader，App ClassLoader，分别负责的加载不同的类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。所以，hotspot使用双亲委派模型保证一个类只能被加载一次，确立了其在虚拟机中的唯一性。</p><p>1）Bootstrap ClassLoader</p><p>​     启动类加载器，负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar中的class。</p><p>（2）Extension ClassLoader</p><p>​    扩展类加载器，负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar。</p><p>（3）App ClassLoader</p><p>​    系统类加载器，负责加载当前java应用的classpath中的所有类。</p><p>​     双亲委派模型就是一个类收到类加载请求后，它首先不会尝试自己加载这个类，而是把这个请求委派为父类加载器取处理。因此，所有的请求都会送到顶层的启动类加载器中，只有父类无法加载请求，子加载器才会尝试自己去加载。</p><p><img src="/2019/04/06/从java类加载机制解析变量初始化/jvmload2.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《深入理解java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​         java类加载机制对我来说总是熟悉又陌生，之前也单独是进行了解过，但总是当时很明白，过了一段时间这块又忘的差不多了。所以
      
    
    </summary>
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MAT中指标解释</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/05/MAT%E4%B8%AD%E6%8C%87%E6%A0%87%E8%A7%A3%E9%87%8A/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/05/MAT中指标解释/</id>
    <published>2019-04-05T14:46:40.000Z</published>
    <updated>2019-04-05T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>​       在用MAT进行内存快照分析时会看到有两个指标Shallow Heap和Retained Heap，下面给出这两个指标的含义：</p><p>（1）Shallow Heap</p><p>​       中文释义“表面上的堆大小”指的是对象本身占有内存的大小，不包含其引用对象的大小。常规对象该指标是对象的数量和类型的大小决定，数据则由类型的大小和数据的长度决定。</p><p>（2）Retained Heap</p><p>​       中文释义“持有的堆的大小”指的是当该对象被回收时那些将被回收的对象集合多有对象大小叠加的大小（包括其本身大小）。例如有一个ArrayList持有10个对象，每个对象带下是4bytes，其本身的大小是X，那么其Retained Heap则为10 * 4 + X。</p><p>下面给出MAT中相关截图：</p><p><img src="/2019/04/05/MAT中指标解释/mat.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​       在用MAT进行内存快照分析时会看到有两个指标Shallow Heap和Retained Heap，下面给出这两个指标的含义：&lt;/p&gt;
&lt;p&gt;（1）Shallow Heap&lt;/p&gt;
&lt;p&gt;​       中文释义“表面上的堆大小”指的是对象本身占有内存的大小，
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>从String.intern()方法浅谈堆中常量池</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/04/%E4%BB%8EString-intern-%E6%96%B9%E6%B3%95%E6%B5%85%E8%B0%88%E5%A0%86%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/04/从String-intern-方法浅谈堆中常量池/</id>
    <published>2019-04-04T15:27:08.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​       String是我们最常用的一个类，和普通java类一样其对象会存在java堆中。但是String类有其特殊之处，可以通过new方法生成，也可以通过带引号的字符串常量直接赋值。在JDK7之前，字符串常量是存在永久带Perm 区的，JDK7开始在将常量池迁移到堆中，这个变化也导致了String的新特性，下面我们慢慢进行介绍。</p><h1 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h1><p>简单的说，String.intern()方法的作用就是返回常量池中字符串对象，在对该方法进行详解之前，我们看几个创建字符串对象的例子。以下说明及运行结果都是以JDK8为java环境。</p><p>（1）直接赋值字符串常量</p><p>​      这种方式会判断常量池中是否存在字符串常量，如果存在返回该常量对象，否则在常量池中创建常量对象并返回。</p><p><code>//在常量池中创建常量“abc”，s1,s2指向常量池中对象地址        String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//true</code></p><p>（2）通过new关键字创建</p><p>​      这种方式会在堆上创建String对象，如果常量池中没有该常量，将常量加入常量池中。</p><p><code>//在堆上创建对象S3,S4,常量池中创建对象“abc”String s3 = new String(&quot;abc&quot;);String s4 = new String(&quot;abc&quot;);System.out.println(s3 == s4);//false</code></p><p>（3）字符串常量相加</p><p>​       这种方式如s5，会在常量池中创建”cd”,”ef”,”cdef”三个对象，s5指向常量池中的”cdef”对象。</p><p><code>String s5 = &quot;cd&quot; + &quot;ef&quot;;String s6 = &quot;cdef&quot;;System.out.println(s5==s6);//true</code></p><p>（4）两个new的String对象相加</p><p>​      这种方式如s7，会在堆中创建三个对象”gh”对象，”lm”对象，以及”ghlm”对象，在常量池中创建对象”gh”,”lm”。</p><p><code>String s7 = new String(&quot;gh&quot;) + new String(&quot;lm&quot;);String s8 = &quot;ghlm&quot;;System.out.println(s7==s8);//false</code></p><p>（5）字符串常量与new的String对象相加</p><p>​     这种方式如s9，会在堆中创建两个对象“op”，“mnop”，并将字符串常量“op”, “mn”加到常量池中。</p><p><code>String s9 = &quot;mn&quot; + new String(&quot;op&quot;);String s10 = &quot;mnop&quot;;System.out.println(s9==s10);//false</code></p><p>​     了解字符串常量的创建及其在内存中的存储，我们看native方法intern()的作用：判断String对象的常量值是否存在于常量池中，如果存在并且是常量池对象，返回该常量池对象；如果存在并且是指向堆中的对象，返回堆中对象地址；如果不存在，则将对象的引用复制到常量池，并返回该对象的引用。下面我们看几条语句的运行结果，第一个输出之所以为true，</p><p><code>String s11 = new String(&quot;a&quot;) + new String(&quot;a&quot;);s11.intern();//由于常量池中无“aa”,因此在常量池中建“aa”的引用,指向堆中的s11String s12 = &quot;aa&quot;;//s12指向常量池中的对象（该对象指向S11）System.out.println(s11 == s12.intern());//trueString s13 = new String(&quot;b&quot;);s13.intern();//常量池中已经有“b”了，不做任何操作String s14 = &quot;b&quot;;System.out.println(s13==s14.intern());//false</code></p><p>​      如果理解了以上运行的结果，对intern()方法的左右就掌握的差不多了。那么久可以开始我们的主题，string pool，字符串常量池。</p><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>​       字符串常量池是jvm为了减小内存开销而在创建字符串对象时的一个优化，类似缓冲区。在hotspot中，字符串常量池是一个叫做StringTable的HashTable，默认长度是1009，在JDK7开始可以通过”-XX:StringTableSize=1009” 参数来设置，字符串常量池数据可以被gc回收（在JDK6及其以前，字符串常量存在永久带无法被gc回收，如果添加太多字符串常量到该区域，容易发生OOM）。由于字符串常量池是利用HashTable实现，因此一定会发生hash碰撞。jvm在这方面做了一定优化，会根据hashTable的碰撞情况来决定是否做rehash，当从这个StringTable里查找某个字符串是否存在，如果对其对应的桶链表进行遍历，遍历超过了100个节点还是没有找到，那就会设置一个flag，让下次进入到safepoint的时候做一次rehash动作，尽量减少碰撞的发生。当然，在数据量比较大的情况下，这也无法从根本上解决问题，只能设置StringTableSize的值来缓解。</p><p>​       由于JDK7开始字符串常量池在堆中分布，所以young gc过程会扫描该区域，以保证处于新生代的String对象不会被回收掉，因此如果字符串常量区非常庞大会导致young gc过程扫描的时间也会变长。但是，young gc阶段并不会对字符串常量区进行回收，具体回收阶段是在Full gc或者CMS gc阶段（题外话：我觉得full gc这个名字并不是很好，容易理解为对所有区域进行回收，其实full GC是对老年代的STW的gc，full gc的次数是老年代gc的STW次数，时间是老年代STW的总时间）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​       String是我们最常用的一个类，和普通java类一样其对象会存在java堆中。但是String类有其特殊之处，可以通过ne
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>对full gc, cms gc, magor gc的疑问</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/04/gc%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/04/gc定义解析/</id>
    <published>2019-04-04T01:34:54.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​        在日常的学习和问题排查中，我们经常会遇到full gc，cms gc，magor gc这几个概念，而对这几个概念的理解可能会有些偏差。如果单纯从名词解析上来讲，执着的弄清楚这几个概念可能就是在浪费时间。但是，如果可以通过对概念的辨析加深对java垃圾回收的理解，这些时间也是值得的。这里，我将对这几个概念进一步理解，纠正自己以前的错误认知。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h3 id="cms-gc"><a href="#cms-gc" class="headerlink" title="cms gc"></a>cms gc</h3><p>​        cms垃圾回收算法是我们线上使用的老年垃圾回收算法，以其较短的停顿时间而被广泛应用，也是jvm中最重要的一个垃圾回收算法。顾名思义，cms gc就是cms回收算法中的各个步骤，这里既有导致STW的初始标记阶段和最终标记阶段，也有和应用线程并发执行的其他阶段，它们都是cms gc。</p><h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>​        我理解full gc就是针对老年代/metaspace区域（Java8之前为永久带）进行的可以导致STW的gc。这里面有个重要的点，只有导致STW的gc才能成为full gc。以我们对cms 算法的了解，如果cms算法正常运行，会发生两次STW。那么以我们讲的概念这样的cms gc会带到两次full gc，下面我们通过jstate命令以及gc日志中cms gc发生的次数来验证这个问题。以我们线上一台机器为例：我们看下统计full gc的数量如下，看出发生了4次full gc。</p><p><img src="/2019/04/04/gc定义解析/gc4.png" alt="gc4"></p><p>​       我们看gc日志看到full 2是最大的cms数量，也就是发生两次cms gc，如上面我们的计算相符。具体如下图：</p><p><img src="/2019/04/04/gc定义解析/gc5.png" alt="gc5"></p><p>​         所以可以这样说，cms中的STW的阶段属于full gc，其他阶段不属于full gc。</p><p>​        正常的full的时间不会很长，如上面的平均时间是0.718/4=0.1795s，但是异常情况下，如如果发生了promotion failed，或者concurrent model failure现象，STW的时间就会很长。这两种情况下的gc并不是由gc线程来执行的，<strong>而是由vm thread 执行的</strong>，整个过程都会STW。先说promotion failed，这是由于在年轻带发生young gc时，eden区晋升的对象，在survivor中发不下，导致年轻带放弃young gc而直接由vm 线程触发一次老年代的gc，这个过程只有单线程执行，完全的STW，因此时间比较长。下面我们看一个promotion failed的例子，我们看到发生了9次full gc。</p><p><img src="/2019/04/04/gc定义解析/gc6.png" alt></p><p>​        查看gc日志，我们看到第五次cms gc是promotion failed引起的且时间用了3.84s，我们计算full gc的次数为4次正常的cms gc带来的8次full gc 加 一次vm thread触发的full gc，一共9次。</p><p><img src="/2019/04/04/gc定义解析/gc7.png" alt></p><p>​        说完promotion failed，我们要说一下concurrent model failure，如果cms gc在执行过程中vm 线程触发了一次full gc，那么这个时候就会产生concurrent model failure，这个时候问题会更加严重，垃圾回收算法会退化为Serail Old，单线程执行，切完全的STW。其实，这里讲的vm 线程触发的full gc和正常的cms gc的实现都在concurrentMarkSweepGeneration.cpp，只不过有着不同的执行路径，vm线程触发的full gc又被称为The background collector，而正常的cms算法被称为The foreground collector。从英文名字中可以清晰的明白前者是后台触发的，而后者是由相应线程主动触发的。</p><h3 id="magor-gc"><a href="#magor-gc" class="headerlink" title="magor gc"></a>magor gc</h3><p>​       我理解的magor gc就是full gc，他们是同一个概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;​        在日常的学习和问题排查中，我们经常会遇到full gc，cms gc，magor gc这几个概念，而对这几个概念的理解可能
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>从gc日志学习gc相关知识</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/03/gc%E6%97%A5%E5%BF%97/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/03/gc日志/</id>
    <published>2019-04-03T11:45:10.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​       最近又对gc有了很大的兴趣，重新对之前gc相关的知识进行学习，其实是看了寒泉子大神gc相关的博客，觉得真的是厉害，这里先记录下如何去阅读gc日志吧。</p><h1 id="gc日志解读"><a href="#gc日志解读" class="headerlink" title="gc日志解读"></a>gc日志解读</h1><h2 id="young-gc-日志"><a href="#young-gc-日志" class="headerlink" title="young gc 日志"></a>young gc 日志</h2><p>我们通过具体的日志进行讲解，如下：</p><p><img src="https://i.bmp.ovh/imgs/2019/04/a6e1021877073145.png" alt>)</p><p>最前面的”Allocation Failure”表示young gc原因，ParNew表示年轻代使用串行多线程垃圾回收器。</p><p>1.表示年轻代垃圾回收期使用的是ParNew;</p><p>2.年轻代回收前使用的大小是81920K;</p><p>3.年轻代回收后使用大小是9566K，可以推断出回收对象大小是81920k-9566k=72354k；</p><p><img src="https://i.bmp.ovh/imgs/2019/04/0f71ecb09d7b9255.png" alt></p><p>5.年轻带垃圾回收的时间；</p><p>6.回收前整个堆的使用大小；</p><p>7.回收后整个堆的使用大小；</p><p>9.这个堆内存回收使用的时间；</p><p>10.指的是gc线程在用户态的时间，如果是多线程的gc算法，该时间是叠加了多线程的时间；</p><p>11.指的是gc线程在内核态的时间，如果是多线程的gc算法，该时间是叠加了多线程的时间；</p><p>12.指的是gc操作从开始到结束的墙钟时间，包括各种非运算的耗时，例如等待磁盘IO，等待线程阻塞，而CPU事件不包括这些事件。我理解这块时间就是gc操作从开始到结束的全部时间。应用程序暂停的时间，对于使用串行垃圾收集时real 大致等于 sys + user; 如下图是使用serial串行垃圾回收算法各部分时间（real 大致等于 sys + user，个人感觉是舍入规则导致不完全相等）。</p><p><img src="https://i.bmp.ovh/imgs/2019/04/212f99d94fc26190.png" alt></p><h2 id="full-gc-（CMS）日志"><a href="#full-gc-（CMS）日志" class="headerlink" title="full gc （CMS）日志"></a>full gc （CMS）日志</h2><p>CMS是老年代垃圾回收算法，由于其避免了长时间的停顿被广泛应用，我们线上老年代都使用的这种算法。下面进行相关讲解：</p><ul><li>阶段一：初始标记（CMS Initial Mark）</li></ul><p>该阶段应用线程会进行一次STW，是CMS算法中两次STW之一，主要工作是：标记GC ROOTS 可达大老年代对象，标记年轻带对象引用的老年代对象。该阶段不会对间接引用对象进行关联，因此该阶段很快。</p><ul><li>阶段二：并发标记（CMS-concurrent-mark）</li></ul><p>该阶段会通过对阶段一标记出的老年带对象进行递归标记，标记处可达的所有对象。该阶段与应用线程是并发执行，因此会出现阶段一种标记的对象引用发生变化，或年轻带对象晋升到老年带，或对象直接分配到老年等情况，在该阶段也会把这些对象所在的Card标记为Dirty，以便在下个阶段处理。</p><ul><li>阶段三：并发预清理（CMS-concurrent-preclean）</li></ul><p>该阶段主要做两件事，一个是处理在并发标记阶段标记的Dirty Card中对象，重新标记引用发生变化的对象；另一个是在并发标记阶段会出现新生代新对象引用老年代对象，这个阶段需要标记这些对象。该阶段和应用线程是并发执行的，可以通过参数CMSPrecleaningEnabled关闭该对象。</p><ul><li>阶段四：可中断预清理（CMS-concurrent-abortable-preclean）</li></ul><p>由于在重新标记阶段会进行CMS中另一次STW，对老年代活跃对象进行重新标记，因此为了减小重新标记阶段阶段STW的时间，在重新标记阶段之前加入该过程进行一定的清理工作。该阶段发生的条件是eden区内存使用量大于CMSScheduleRemarkEdenSizeThreshold，默认是2M。因此该阶段主要工作一个是处理Dirty Card中的对象；另一个是处理年轻带对象，标记活跃的老年代对象。该阶段和应用线程并发进行，会循环执行下去，直到时间达到CMSMaxAbortablePrecleanTime（默认5s）或者次数达到CMSMaxAbortablePrecleanLoops（默认无限制）或者eden区使用率达到CMSScheduleRemarkEdenPenetration（默认50%）。可以知道，该阶段会扫描年轻带对象，如果再该阶段之前进行一次young gc 减小年轻带活跃对象数目，会加快该阶段速度，可以通过参数CMSScavengeBeforeRemark来控制。</p><ul><li>阶段五：重新标记（CMS Final Remark）</li></ul><p>如上所述，该阶段是CMS中另一个STW阶段，需要尽可能的减小该阶段时间，上面的阶段三，阶段四的存在正式为了这一点。该阶段的工作一个是遍历GC ROOTS 进行重新标记，一个是遍历新生代对象重新标记，另一个是遍历Dirty Card重新标记。</p><ul><li>阶段六：清理阶段（CMS-concurrent-sweep）</li></ul><p>该阶段会清理不活跃的老年代对象，该阶段与应用线程并发进行。</p><ul><li>阶段七：重置阶段</li></ul><p>该阶段会重置CMS算法相关的数据结构，为下次gc做准备，该阶段与应用线程并发执行。</p><p>老年代gc回收的相关日志如下，这里不进行解读，容量，时间相关参数和年轻大大致类似。</p><p><code>1.803: [CMS-concurrent-mark-start]1.957: [GC (Allocation Failure) 1.958: [ParNew: 92159K-&gt;10239K(92160K), 0.1382680 secs] 565579K-&gt;565578K(1038336K), 0.1383043 secs] [Times: user=0.81 sys=0.05, real=0.14 secs] 2.163: [GC (Allocation Failure) 2.163: [ParNew: 92159K-&gt;10239K(92160K), 0.1259734 secs] 647498K-&gt;647496K(1038336K), 0.1260101 secs] [Times: user=0.70 sys=0.04, real=0.12 secs] 2157ms2.671: [CMS-concurrent-mark: 0.603/0.867 secs] [Times: user=2.77 sys=0.10, real=0.86 secs] 2.671: [CMS-concurrent-preclean-start]2.842: [CMS-concurrent-preclean: 0.172/0.172 secs] [Times: user=0.17 sys=0.00, real=0.18 secs] 2.842: [CMS-concurrent-abortable-preclean-start] CMS: abort preclean due to time 7.996: [CMS-concurrent-abortable-preclean: 2.430/5.153 secs] [Times: user=2.41 sys=0.01, real=5.15 secs] 7.996: [GC (CMS Final Remark) [YG occupancy: 28252 K (92160 K)]7.996: [Rescan (parallel) , 0.0047059 secs]8.001: [weak refs processing, 0.0000344 secs]8.001: [class unloading, 0.0002629 secs]8.001: [scrub symbol table, 0.0005571 secs]8.002: [scrub string table, 0.0001773 secs][1 CMS-remark: 637257K(946176K)] 665509K(1038336K), 0.0058199 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] 8.002: [CMS-concurrent-sweep-start]8.353: [CMS-concurrent-sweep: 0.351/0.351 secs] [Times: user=0.35 sys=0.00, real=0.35 secs] 8.353: [CMS-concurrent-reset-start]8.356: [CMS-concurrent-reset: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></p><p>full gc是我们比较担心的事情，因为会出现较长的STW，那么什么情况下会触发full gc呢，下面我列出几种情况：</p><ul><li>老年代使用率达到阈值 CMSInitiatingOccupancyFraction（该值默认是92%）；</li><li>新生代晋升担保失败，也就是由于新生代survivor区域大小无法容纳eden区存活的对象，直接晋升到老年代，老年代没有足够空间，需要进行一次full gc。</li><li>代码执行System.gc()并且没有参数ExplicitGCInvokesConcurrent，也会触发full gc；</li><li>jdk1.7及之前还存在永久代时，在开启 CMSClassUnloadingEnabled时，如果永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction（该值默认是92%）。在jdk1.8及以后永久代被metaspace替代，metaspace区域也是使用cms进行垃圾回收，可以设置该区域发生gc的初始阈值的MetaspaceSize，但是该阈值会一直变化，对该区域参数的相关介绍可以参考<a href="https://mp.weixin.qq.com/s/SsXbRvtvawKDHstFpU4uog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SsXbRvtvawKDHstFpU4uog</a> 。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​       最近又对gc有了很大的兴趣，重新对之前gc相关的知识进行学习，其实是看了寒泉子大神gc相关的博客，觉得真的是厉害，这里先记录
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
  </entry>
  
</feed>
