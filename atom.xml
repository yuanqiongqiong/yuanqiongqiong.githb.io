<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>袁琼琼的博客</title>
  
  <subtitle>一个想在技术道路走下去的小渣渣，多多关照！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yuanqiongqiong.cn/"/>
  <updated>2019-06-09T04:22:40.000Z</updated>
  <id>https://www.yuanqiongqiong.cn/</id>
  
  <author>
    <name>袁琼琼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树</title>
    <link href="https://www.yuanqiongqiong.cn/2019/06/09/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://www.yuanqiongqiong.cn/2019/06/09/红黑树/</id>
    <published>2019-06-09T03:36:57.000Z</published>
    <updated>2019-06-09T04:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​       二叉搜索树是优化搜索效率最常用的数据结构，时间复杂度为O(h)，其中h是树的高度。可以看出，树的高度是影响搜索效率的关键因素。在树退化为一个链表(节点都在左或都在右)，搜索效率也就退化为O(n)。为了防止这种情况的出现平衡二叉搜索树出现，本文所介绍的红黑树就是一种特殊的”平衡”二叉树，因为红黑树只能保证没有一条路径会比其他路径长出2倍，所以并不是严格意义上的平衡树。但是这个性质却能保证最坏情况下搜索操作的复杂度是O(h)。</p><h1 id="定义及性质"><a href="#定义及性质" class="headerlink" title="定义及性质"></a>定义及性质</h1><p>​      红黑树每个节点包含color，key，left，right和p，如果一个节点没有子节点或者父节点，那么该节点响应指针的属性值为NIL，我们将NIL视为指向也节点的指针。一个红黑树必须满足一下性质：</p><p>(1) 每个节点只能是红色或者黑色；</p><p>(2) 根节点是黑色；</p><p>(3) 每个叶节点（NIL）是黑色；</p><p>(4) 红节点的子节点一定是黑色；</p><p>(5) 对于每个节点，从该节点到到期所有后代也节点的路径上，均包含相同数目的黑节点。</p><h1 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h1><p>​       红黑树的插入操作和一般的二叉搜索树一样，但是插入节点后需要进行调整，以满足红黑树的以上五个性质。我们知道JDK8中的HashMap和ConcurrentHashMap在桶中链表长度大于等于8时会将链表转换为红黑树以提高搜索效率，下面我们通过这块代码来了解下具体调整算法。下面代码涉及两个操作：左旋和右旋，大家可以认为对x节点左旋就是用x节点的右子节点y代替x，并且x成为y的左子节点；对x节点进行右旋就是用x的左子节点y代替x并且x成y的右子节点。</p><p><img src="/2019/06/09/红黑树/左旋右旋.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; ConcurrentHashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(ConcurrentHashMap.TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                  ConcurrentHashMap.TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.所有新插入的节点颜色都是红色</span></span><br><span class="line">        x.red = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (ConcurrentHashMap.TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">            <span class="comment">//如果节点是根节点，那么直接将该节点置为黑色，结束</span></span><br><span class="line">            <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果x的父节点是黑色，符合红黑树定义直接返回。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            <span class="comment">//2.插入的节点x的父节点是红色并且是左子树</span></span><br><span class="line">            <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                <span class="comment">//2.1查看x的叔叔节点的颜色，如果是红色，那么将x的父节点，叔节点置为黑色，爷爷节点置为红色，并将要调整的节点置为爷爷节点</span></span><br><span class="line">                <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                    xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xpp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//2.2 x节点的叔叔节点是黑色，且x是右子树，那么将x的父节点进行右旋</span></span><br><span class="line">                    <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                        root = rotateLeft(root, x = xp);</span><br><span class="line">                        xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">//2.3 x节点的叔叔节点是黑色，且x是左子树，将父节点置为黑色，爷爷节点置为红色并将爷爷节点进行右旋</span></span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                            root = rotateRight(root, xpp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//3.插入节点x父节点是红色并且是右子树，处理过程与情况2相同</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                    xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xpp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                        root = rotateRight(root, x = xp);</span><br><span class="line">                        xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                            root = rotateLeft(root, xpp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><p>​     相对于红黑树的插入操作，删除操作比较麻烦，我们按照被删除节点x的颜色和x的子节点情况分类如下。为了更容易理解在有的情况下我们给出了操作图，红色代表红节点，黑色代表黑节点，白色代表不知道该节点是红还是黑，并且为了简化图示我们没有将NIL节点画出，大家可以认为所有页节点都隐含一个黑色节点NIL。</p><p>(1) x为红色并且x没有子节点</p><p>​     这种情况下较为简单，直接删除x不会破坏红黑树上述五个限制。</p><p>(2) x为红色并且x有一个子节点</p><p>​     这种情况实际是不存在的，因为如果x是红色，其子节点必定是黑色，而左右子树的黑高就不相等。</p><p>(3) x为黑色并且x有一个子节点</p><p>​     这种情况下，x的这个子节点y必定是红色，因此只需要将y替换为x并且将y置为黑色即可。具体如下图：</p><p><img src="https://i.bmp.ovh/imgs/2019/06/678b78e378e317ff.png" alt></p><p>(4) x为红色并且x有两个子节点</p><p>​     这种情况下，可以找到x节点的后继节点s，s的情况可能有以下两种：</p><p><img src="https://i.bmp.ovh/imgs/2019/06/250e551ce4b5fdf9.png" alt></p><p>删除x时可以用s替换为x，并将s的颜色设置为x的颜色。此时删除x相当于删除s。如果s没有子节点则这种情况转换为(1)或者(6)，如果s有子节点，这种情况转换为(2)或者(3)。我们以比较负责的情况x的后继节点有一个子孩子并且s为黑色为例给出删除示例：<img src="https://i.bmp.ovh/imgs/2019/06/4b1196ebd3b872f0.png" alt></p><p>(5) x为黑色并且x有两个子节点</p><p>​       这种情况同(4)的处理机制一样。    </p><p>(6) x为黑色并且x没有子节点</p><p>​       这种情况比较复杂，因为删除黑节点会破坏黑高。可以分为如下几种情况讨论：</p><p>(a). x节点的兄弟节点b有一个与其方向一致的红色子节点s</p><p>​       此时将父节点进行旋转，并将删除节点的黑色转移到父节点，而父节点原来位置的颜色保持不变。</p><p><img src="https://i.bmp.ovh/imgs/2019/06/8834333ca8a069f7.png" alt></p><p>(b). x节点的兄弟节点b有一个与其方向不一致的红色节点s</p><p>​       此时首先通过旋转操作转为情况(a)，再按照(a)进行处理。</p><p><img src="https://i.bmp.ovh/imgs/2019/06/03f75c934ca40bcf.png" alt></p><p>(c) 兄弟节点为黑色，且兄弟节点无红色子节点</p><p>​       如果父节点是红色，那么将父节点置为黑色，兄弟节点置为红色即可解决问题。</p><p>​      <img src="https://i.bmp.ovh/imgs/2019/06/8e4c7893af272544.png" alt></p><p>​       如果父节点是黑色，那么确实没有红节点可以作为黑节点转移的节点，只能对兄弟节点重新设置颜色，已平衡被删除节点侧减小的黑高，并即将节点一直上移知道根节点使得所有的路径的黑高都减1。</p><p>(d) 兄弟节点为红色</p><p>​       这种情况可以通过旋转父节点，转换为父节点为红色，兄弟节点为黑色的情况处理。</p><p>​       从以上的删除过程可以看出，如果删除节点是红色节点，不会破会黑高，可以直接删除。如果删除的节点是黑色节点，并且删除的节点的父节点或者兄弟节点，兄弟节点的子节点存在红色节点，那么可以通过旋转操作即将红色节点旋转到被删除节点侧并置为黑色保持黑高不改变。如果以上节点都不存在红色节点，那么只能向上回溯整个树的黑高整体减一。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>算法导论</p><p><a href="https://segmentfault.com/a/1190000012115424" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012115424</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​       二叉搜索树是优化搜索效率最常用的数据结构，时间复杂度为O(h)，其中h是树的高度。可以看出，树的高度是影响搜索效率的关键因素
      
    
    </summary>
    
      <category term="数据结构" scheme="https://www.yuanqiongqiong.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.yuanqiongqiong.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="https://www.yuanqiongqiong.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ConcurrentHashMap的扩容机制</title>
    <link href="https://www.yuanqiongqiong.cn/2019/06/08/%E8%B0%88%E8%B0%88ConcurrentHashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.yuanqiongqiong.cn/2019/06/08/谈谈ConcurrentHashMap的扩容机制/</id>
    <published>2019-06-08T03:57:54.000Z</published>
    <updated>2019-06-09T04:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​        HashMap是我们日常开发中最常用的一个类，但是该类在多线程情况下无法宝成集合操作的安全性，JDK提供了HashTable和ConcurrentHashMap作为多线程下并发安全的集合，而ConcurrentHashMap以其高并发性成功使用最广泛的类。我们都知道HashMap通过哈希值将元素映射到特定的桶中，无论多么优秀的hash算法都无法避免而冲突，以上所述的几种hashmap都是通过拉链法解决冲突。而每个桶中链表较长有会影响查询效率，极端情况下所有的元素都在一个桶中，此时查找效率从O(1)退化为O(n)，为了尽可能的避免这种现象hashmap通常会在装载因子大于特定值时开始扩容，也就是增加桶的数量。这篇博客就讲讲ConcurrentHashMap的扩容机制。</p><h1 id="Jdk8中ConcurrentHashMap扩容机制"><a href="#Jdk8中ConcurrentHashMap扩容机制" class="headerlink" title="Jdk8中ConcurrentHashMap扩容机制"></a>Jdk8中ConcurrentHashMap扩容机制</h1><p>​        Jdk8摒弃了Jdk7中ConcurrentHashMap的段锁的实现方式，使用CAS+synchronized保证线程安全性，而扩容操作的线程安全也是通过这种方式保证。在map中元素个数较多的情况下，扩容操作是一个费时的操作，ConcurrentHashMap为了充分利用多线程，会将map中的桶按一定数量分配给各个线程处理，每个线程不会处理到相同的桶。我们先看下示意图，map中有64个槽，每个线程每次处理16个槽，有3个线程参与扩容并且线程1最先完成了分配的第一段槽，具体分配示意图如下：</p><p><img src="https://i.bmp.ovh/imgs/2019/06/26a1ad153329a517.png" alt></p><p>​        下面我们看下扩容的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> tab       扩容前槽数组</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> nextTab   扩容后槽数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="comment">//1.计算步长(每个线程每次分配的超节点数目)，如果机器核数大于1并且原槽节点数目除以8*NCPU大于16，那么步长就是原槽节点数目除以8*NCPU，否者默认是16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="comment">//2.如果是第一个线程进入扩容操作，要首先初始化扩容后槽数组，size会变为原来的2倍</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            <span class="comment">//该变量很关键记录槽节点已经分配的位置，volatile类型，保证修改可见性</span></span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">//标记节点已经完成迁移，查询需要在新的槽数组中查找</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="comment">//标记是否进行下一轮槽节点分配</span></span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//标记扩容是否完成</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="comment">//处理下一个槽节点</span></span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//CAS分配槽节点，开始槽为nextIndex - stride(如果剩余槽数量小于stride，开始为0)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入扩容时，扩容已经结束，进行相应处理</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">//更新阈值</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果第i处的槽位null,则设置为fwd，个人认为是处理那些原本为null的槽</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">           <span class="comment">//如果节点已经是fwd，那么继续循环，分配槽节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//进行节点重分配，真正的核心，对头节点加锁，防止向槽的链表（或红黑树）中插入数据</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      <span class="comment">//扩容过程中会根据节点key的hash值的logn + 1 (logn表示以2为底n的对数)位是0还是1分为两个链表，是0的节点新老槽数组中位置不变，是1的链表会放在心数据的 n+i个槽上(是不是很巧妙，省去了hash值的计算，这也是map中长度一直是2的指数次带来的便利)</span></span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="comment">//如果是普通的链表节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//首先取头结点的是0还是1</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">//第一次遍历链表，找到到尾节点的高位都是0或者都是1的第一个节点，因为这个节点之后的所有节点会在新槽数组的相同位置，下面会统一处理不用循环遍历</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果上面循环找到的是链表是地位那么赋值为ln</span></span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//否则赋值为hn</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//重新遍历链表，构建ln和hn</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//ln放在原来的位置第i个槽</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">//hn放在第i+n个槽</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">//将老的槽数组置为fwd</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                       <span class="comment">//如果节点是红黑树</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="comment">//同样按高位是0和1分配为两个链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果链表数目小于等6，那么将红黑树节点链表转为普通节点链表，否则生成一棵红黑树</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        以上就是JDK8中ConcurrentHashMap的扩容过程，充分利用多线程提高扩容效率，同时通过为每个线程分配不同范围的槽节点，避免竞争，通过synchronized关键字解决put操作带来的可能造成的并发问题。相比JDK7中将hashMap的桶分为16个互不影响的段，每个段中的扩容只有一个线程会进行扩容操作，完全通过端上的锁保证安全性。JDK8中的扩容机制更加的高效，多线程同时参与。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​        HashMap是我们日常开发中最常用的一个类，但是该类在多线程情况下无法宝成集合操作的安全性，JDK提供了HashTabl
      
    
    </summary>
    
      <category term="java集合" scheme="https://www.yuanqiongqiong.cn/categories/java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="HashMap" scheme="https://www.yuanqiongqiong.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Spring中配置文件命名空间</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/15/Spring%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/15/Spring中配置文件命名空间/</id>
    <published>2019-04-15T14:36:32.000Z</published>
    <updated>2019-04-15T14:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​      在做需求中发现自己对spring配置文件不熟悉，导致在引用一些标签进行配置时出现问题。所以，这里对spring配置文件的命名空间进行学习，以便增加对spring的认识深度。</p><h1 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h1><p>​         Spring配置文件用于指导spring进行bean的生成，装配等工作。applicationContext.xml是Spring的默认配置文件，当容器启动时找不到指定的配置文档时，将会尝试加载这个默认的配置文件。既然使用了xml配置文件，那么就有了命名空间的概念。在xml中，命名空间提供了解决定义的相同元素冲突的一种有效方法。在spring配置文件中通过关键字xmlns引入命名空间，然后通过xsi:schemaLocation指定用于解析和校验xml的定义文件（xsd）的位置。</p><p>（1）命名空间声明</p><p>​        命名空间声明的一般形式为：xmlns:命名空间的前缀=”命名空间标识URI”，例如：xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;。还可以隐式声明命名空间，即省略掉冒号和命名空间前缀。但是，一个xml文件中只能有一个隐式声明的命名空间，如常在applicationContext.xml中隐式声明的命名空间：xmlns=&quot;http://www.springframework.org/schema/beans&quot;。" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;。还可以隐式声明命名空间，即省略掉冒号和命名空间前缀。但是，一个xml文件中只能有一个隐式声明的命名空间，如常在applicationContext.xml中隐式声明的命名空间：xmlns=&quot;http://www.springframework.org/schema/beans&quot;。</a></p><p>（2）命名空间对应schema文档声明</p><p>​        xsi:schemaLocation 是为每个命名空间指定了对应的Schema文档，其定义的语法为:xsi:schemaLocation =”全称命名空间1 全称命名空间1对应的Schema文件”。例如：xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</a></p><h1 id="spring配置文件命名空间读取顺序"><a href="#spring配置文件命名空间读取顺序" class="headerlink" title="spring配置文件命名空间读取顺序"></a>spring配置文件命名空间读取顺序</h1><p>​       spring在读取命名空间对应的schema文档时会先去读取jar中存在的xsd文件；如果没有找到，spring会根据配置文件中url取查找。如果没有配置xsd文件的版本号，默认就是jar中最新版本，或者url对应位置的最新版本。所以，配置命名空间可以不必写明版本号。下面给出一个spring配置文件示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.1.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-4.1.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-4.1.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.1.xsd&quot;&gt; &lt;/beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​      在做需求中发现自己对spring配置文件不熟悉，导致在引用一些标签进行配置时出现问题。所以，这里对spring配置文件的命名空
      
    
    </summary>
    
      <category term="spring" scheme="https://www.yuanqiongqiong.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.yuanqiongqiong.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>为什么wait和notify要在同步块内执行？</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/13/%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E5%86%85%E6%89%A7%E8%A1%8C/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/13/为什么wait和notify要在同步块内执行/</id>
    <published>2019-04-13T15:50:04.000Z</published>
    <updated>2019-04-13T15:50:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​      今天看到一个很值得深思的问题”为什么wait()，notify()，notifyAll()方法需要在同步块中执行？“，我的第一反应是wait()方法功能就是释放对象锁进行等待队列，如果没有持有锁，那如何释放呢？很有道理的样子，但其实并没有回答jdk为什么要这么做，今天我们就探讨下具体原因。</p><h1 id="wait和notify的使用"><a href="#wait和notify的使用" class="headerlink" title="wait和notify的使用"></a>wait和notify的使用</h1><p>​      我们先对wait和notify进行介绍，wait()和notify()方法是Object类的两个native方法，是java线程间通信的方式，在一个线程中调用对象的wait()方法，会使得线程阻塞在该对象锁上；调用notify()方法会唤醒在这个对象上阻塞的方法(具体的，该方法会随机唤醒一个阻塞在对象上的线程)。这两个方法使用时总是成对出现，并且必须在同步块中执行。下面看下源码中的相关定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程在挂起，进入阻塞状态，timeout 毫秒时间内没有唤醒会自动被唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//将线程挂起，进入阻塞状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//随机唤醒一个阻塞在该对象上的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒所有阻塞在对象上的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>​      各个方法如何使用都已经注释在代码中，下面我们看一个实际使用的简单示例，在线程thread中挂起线程，然后在主线程中调用notify唤醒线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yuanqiongqiong on 2019/4/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WaitTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> integer object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//避免出现因为调度问题先执行主线程情况</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            logger.info(<span class="string">"挂起线程"</span>);</span><br><span class="line">                            object.wait();</span><br><span class="line">                            logger.info(<span class="string">"线程被唤醒"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            logger.error(<span class="string">"exception = &#123;&#125;"</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        logger.info(<span class="string">"在主线程中"</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;&#125;<span class="comment">//忙等</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            logger.info(<span class="string">"调用notify"</span>);</span><br><span class="line">            object.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">27</span>:<span class="number">40.842</span> [Thread-<span class="number">0</span>] INFO com.qiongqiong.WaitTest - 挂起线程</span><br><span class="line"><span class="number">22</span>:<span class="number">27</span>:<span class="number">40.842</span> [main] INFO com.qiongqiong.WaitTest - 在主线程中</span><br><span class="line"><span class="number">22</span>:<span class="number">27</span>:<span class="number">40.845</span> [main] INFO com.qiongqiong.WaitTest - 调用notify</span><br><span class="line"><span class="number">22</span>:<span class="number">27</span>:<span class="number">40.845</span> [Thread-<span class="number">0</span>] INFO com.qiongqiong.WaitTest - 线程被唤醒</span><br></pre></td></tr></table></figure><p>​       如前所述，wait和notify必须在同步块里执行，并且这个synchronized锁定的对象一定是调用wait和notify对象。否则，会抛出java.lang.IllegalMonitorStateExceptiony异常，这是jdk做了一层强制校验。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>​      我们首先从JDK实现的角度分析，我们知道synchronized底层使用monitorenter和monitorexit指令(查看class文件也可以看到)，这块会获取对象锁(monitor)。而wait和notify相关的native方法要求调用时必须持有对象锁。</p><p>​     其次，我们假设如果wait()和notify()不在同步块中并且可以执行上述示例可能出现的结果，thread线程和main线程按照下面顺序执行。</p><table><thead><tr><th style="text-align:left">thread线程</th><th>main线程</th></tr></thead><tbody><tr><td style="text-align:left">logger.info(“挂起线程”);</td><td></td></tr><tr><td style="text-align:left"></td><td>logger.info(“调用notify”);</td></tr><tr><td style="text-align:left"></td><td>object.notify();</td></tr><tr><td style="text-align:left">object.wait();</td></tr></tbody></table><p>​      当main线程执行notify()时，thread线程还没有调用wait，即还处于运行状态，这是这条语句调用没有任何作用。但是，wait()方法执行后，thread线程将永远处于阻塞状态，这个问题就是多线程中的”lost wake up”问题，而jdk为了避免该问题的出现，强制要求我们使用wait和notify时必须持有该对象的锁。</p><p>​      以上就是wait和notify为什么必须在同步块中调用的原因，如果个人理解有问题，欢迎指正！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​      今天看到一个很值得深思的问题”为什么wait()，notify()，notifyAll()方法需要在同步块中执行？“，我的第一
      
    
    </summary>
    
      <category term="java多线程" scheme="https://www.yuanqiongqiong.cn/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="并发" scheme="https://www.yuanqiongqiong.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中使用动态代理机制分析</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/11/MyBatis%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/11/MyBatis中使用动态代理机制分析/</id>
    <published>2019-04-11T15:09:23.000Z</published>
    <updated>2019-04-11T15:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​       近期，对mybatis源码进行了一段粗略的学习，对之前一些不太理解的问题也有了进一步的理解。其中就包括动态代理机制在mybatis中的使用，这篇文章主要对这一点进行分析，以便在日后遗忘的时候可以看一看。</p><h1 id="MyBatis中动态代理"><a href="#MyBatis中动态代理" class="headerlink" title="MyBatis中动态代理"></a>MyBatis中动态代理</h1><p>​       我们都知道Spring中AOP机制就是通过java的动态代理实现的，个人理解动态代理就是一种代理模式的实现，只不过动态代理中的代理类是在运行期生成的(也可以通过该点来区分静态代理和动态代理，静态代理是代理类在编译器就生成了)。java通过Proxy类和InvocationHandler接口方便的实现了动态代理。这里我们不进行动态代理分析，先看看mybatis中如何使用了动态代理，先上一段简单的mybatis实现数据库访问的代码，有一个数据表User记录用户的id,userName,userAge三个属性，其中userMapper.xml文件如下：</p><p><strong>mapper.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!-- 定义操作user表的sql映射文件userMapper.xml  --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.qiongqiong.bean.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;selectUserByID&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from `user` where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>​        接口UserMapper定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yuanqiongqiong on 2018/5/13.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">selectUserByID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       当我们使用调用selectUserByID时会使用如下的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory;</span><br><span class="line">Reader reader;</span><br><span class="line">String resource = <span class="string">"configuration.xml"</span>;</span><br><span class="line">reader= Resources.getResourceAsReader(resource);</span><br><span class="line">sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = (User) userMapper.selectUserByID(<span class="number">1</span>);</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p>​        通过这种方式我们就完成了对数据库的访问操作。但是，大家一定会有疑问，我们没有实现UserMapper接口，userMapper.selectUserByID(1)方法是如何执行的。没错，是java的动态代理，mybatis使用了动态代理机制为UserMapper生成了一个代理类，为了清楚的认识到代理类的实现，我将该代理类的字节码打印到文件中，并在IDEA下进行反编译如下。userMapperProxy类实现了代理类和UserMapper接口。</p><p><strong>UserMapperImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">userMapperProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">userMapperProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List <span class="title">selectUserByID</span><span class="params">(<span class="keyword">int</span> var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (List)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;Integer.valueOf(var1)&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.qiongqiong.bean.UserMapper"</span>).getMethod(<span class="string">"selectUserByID"</span>, <span class="keyword">new</span> Class[]&#123;Integer.TYPE&#125;);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         如普通的动态代理一致，当调用selectUserByID方法时会调用InvocationHandler中的invoke方法，去调用相应的实现方法。我们继续看一下userMapperProxy中的InvocationHandler的实现类MapperProxy，从invoke方法代码中我看出如果调用方法是接口中定义的数据库操作方法，那么执行如下逻辑：MapperMethod mapperMethod = this.cachedMapperMethod(method); return mapperMethod.execute(this.sqlSession, args); 看到这两行代码我们终于明白sql的具体执行，最终还是通过sqlSession来执行。MapperMethod封装了xml具体的sql语句，其实这个执行活动类似 User user =(User) session.selectOne(“selectUserByID”, 1);  这条语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles.Lookup;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.lang.UsesJava7;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.ExceptionUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">        <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isDefaultMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.invokeDefaultMethod(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span>(mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UsesJava</span>7</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Constructor&lt;Lookup&gt; constructor = Lookup.class.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;Class.class, Integer.TYPE&#125;);</span><br><span class="line">        <span class="keyword">if</span>(!constructor.isAccessible()) &#123;</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">        <span class="keyword">return</span> ((Lookup)constructor.newInstance(<span class="keyword">new</span> Object[]&#123;declaringClass, Integer.valueOf(<span class="number">2</span>)&#125;)).unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (method.getModifiers() &amp; <span class="number">1033</span>) == <span class="number">1</span> &amp;&amp; method.getDeclaringClass().isInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​       近期，对mybatis源码进行了一段粗略的学习，对之前一些不太理解的问题也有了进一步的理解。其中就包括动态代理机制在myba
      
    
    </summary>
    
      <category term="数据库" scheme="https://www.yuanqiongqiong.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="mybatis" scheme="https://www.yuanqiongqiong.cn/tags/mybatis/"/>
    
      <category term="数据库" scheme="https://www.yuanqiongqiong.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ThreadPoolExecutor的实现</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/10/%E8%B0%88%E8%B0%88ThreadPoolExecutor%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/10/谈谈ThreadPoolExecutor的实现/</id>
    <published>2019-04-10T02:40:40.000Z</published>
    <updated>2019-04-12T11:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​      线程作为系统稀缺资源，如果在应用中进行频繁的创建和销毁，会为我们的应用带来灾难性的体验，增大系统负荷，降低效率。池化技术为该问题的解决提供了一种有效的思路，通过建立一个线程池，每次线程的时候从池中取出一个空闲的线程，这样就省去了线程创建和销毁。java的线程池实现是在jdk1.5开始引入的，本文将对其中最常用的ThreadPoolExecutor的实现进行详细的介绍，系统可以通过本文了解到如何去实现一个线程池，并向Doug Lea大神致敬。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>​       我们先看下面的线程池使用的例子，在该例子中我声明一个核心线程数是2，最大线程数是5，非核心线程线程存活时间1s，阻塞队列大小为1，拒绝策略为AbortPolicy，我们会输出程序执行过程中的线程池达到的最大线程数以及在所有任务执行结束后线程池中线程的数量。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yuanqiongqiong on 2019/4/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ThreadPoolExecutorTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">7</span>;i++) &#123;</span><br><span class="line">            String runnableName = <span class="string">"test"</span> + i;</span><br><span class="line">            PersonRunnable personRunnable = <span class="keyword">new</span> PersonRunnable(runnableName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                threadPoolExecutor.execute(personRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"执行&#123;&#125;任务异常"</span>, runnableName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            LOGGER.info(<span class="string">"线程池当前线程数目 = &#123;&#125;"</span>, threadPoolExecutor.getPoolSize());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">"线程池中达到的最大线程数目 = &#123;&#125;"</span>, threadPoolExecutor.getLargestPoolSize());</span><br><span class="line">        LOGGER.info(<span class="string">"线程池当前线程数目 = &#123;&#125;"</span>, threadPoolExecutor.getPoolSize());</span><br><span class="line">        LOGGER.info(<span class="string">"线程池已经完成的任务数量 = &#123;&#125;"</span>, threadPoolExecutor.getCompletedTaskCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PersonRunnable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LOGGER.info(<span class="string">"我是"</span> + name + <span class="string">"我在线程"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"任务&#123;&#125;执行异常"</span>, Thread.currentThread().getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">20:22:26.571 [pool-1-thread-3] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test3我在线程pool-1-thread-3</span><br><span class="line">20:22:26.571 [pool-1-thread-2] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test1我在线程pool-1-thread-2</span><br><span class="line">20:22:26.571 [pool-1-thread-4] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test4我在线程pool-1-thread-4</span><br><span class="line">20:22:26.571 [pool-1-thread-5] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test5我在线程pool-1-thread-5</span><br><span class="line">20:22:26.571 [pool-1-thread-1] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test0我在线程pool-1-thread-1</span><br><span class="line">20:22:26.576 [main] ERROR com.meituan.campaign.ThreadPoolExecutorTest - 执行test6任务异常</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task com.meituan.campaign.ThreadPoolExecutorTest$PersonRunnable@46f7f36a rejected from java.util.concurrent.ThreadPoolExecutor@421faab1[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</span><br><span class="line">at com.meituan.campaign.ThreadPoolExecutorTest.main(ThreadPoolExecutorTest.java:30)</span><br><span class="line">20:22:26.681 [pool-1-thread-5] INFO com.meituan.campaign.ThreadPoolExecutorTest - 我是test2我在线程pool-1-thread-5</span><br><span class="line">20:22:27.082 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池当前线程数目 = 5</span><br><span class="line">20:22:29.084 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池中达到的最大线程数目 = 5</span><br><span class="line">20:22:29.084 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池当前线程数目 = 2</span><br><span class="line">20:22:29.085 [main] INFO com.meituan.campaign.ThreadPoolExecutorTest - 线程池已经完成的任务数量 = 6</span><br></pre></td></tr></table></figure><p>​        由于我们代码设置了最大线程数是5个，并且阻塞队列大小是1，所以同一时间最多会有6个任务被执行，其中1个任务放在阻塞队列中。线程池达到的最大线程数目是5个，因为线程池设置了maximumPoolSize=5。非核心线程会在1s空闲后被回收，因此最终线程池线程数目还是2个。</p><h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>​        抛开ThreadPoolExecutor，我们先想下实现一个线程池需要哪些成员变量，个人感觉以下变量是必不可少的：(1) 一个存放线程的容器或数组；(2) 一个队列用来在线程池线程不足是存放排队的任务；(3) 一个状态字段表示线程池的状态，用来表示线程池不同生命周期状态。下面，我们看下ThreadPoolExecutor的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示线程状态和线程数，高三位代表线程状态，低29位代表线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//值为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//线程池最大线程数，大概为5亿，可以肯定不会达到这么多线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程池处于运行状态可以接收新任务并执行任务队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//该状态下线程池不再接收新任务，但是会把任务队列中的任务执行完成，调用shutDown()会进入该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//该状态下线程池不接受新任务并抛弃任务队列中的任务中断所有正在执行的线程，调用shutDownNoW()会进入该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//已经没有任务可以执行，会从SHUTDOWN和STOP状态变换为该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//在执行完terminated()操作后会进入该状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//任务阻塞队列，存放排队任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//存放线程的hashset</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//线程工厂，生成新线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//线程池核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//线程池最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><p>​         上述代码的注释给出了线程池各个状态的含义，我们看下各个状态之间的状态转换关系，具体如下：</p><p>(1) RUNNING -&gt; SHUTDOWN：调用了shutdown()函数；</p><p>(2) (RUNNING or SHUTDOWN) -&gt; STOP：调用了shutdownNow()；</p><p>(3)SHUTDOWN -&gt; TIDYING：当线程池线程为空并者任务队列为空；</p><p>(4)STOP -&gt; TIDYING：当线程池线程为空；</p><p>(5)TIDYING -&gt; TERMINATED：当调用了terminated()方法；</p><p>​       如上示例，我们把一个任务放入线程池的execute()函数中，线程池会为我们选择一个线程来执行我们提交的任务。在这个选择线程的过程中，如果线程池中线程数量小于corePoolSize，那么将创建新线程执行任务；当线程池数量大于等于corePoolSize并且小于maximumPoolSize，线程池会把任务放到阻塞队列workQueue中直到workQueue满了去创建新线程；当线程池线程数量等于maximumPoolSize并且workQueue满时会执行拒绝策略。下面我们通过execute()函数的逻辑来理解上述过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//如果线程数小于核心线程数，那么创建一个新的线程来执行任务command</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果线程数大于等于核心线程数，线程数处于RUNNING状态(可以将任务加入阻塞队列)并且加入阻塞队列成功(即阻塞队列未满)，那么任务就被加入阻塞队列等待空闲线程。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//再次检查线程池状态，如果不是RUNNING状态，从阻塞队列中移除任务，执行拒绝策略</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//线程处RUNNING状态并且线程数是0，则创建个空闲新线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果线程数大于核心线程并且阻塞队列已满，则以maximumPoolSize为线程数最大值进行处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            <span class="comment">//线程池中线程达到最大线程数并且阻塞队列已经满执行拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​       看到上面的代码逻辑，我们会发现主要的逻辑还是在addWorker里，这个函数主要功能就是为任务分配线程并执行，我们在看这块逻辑之前需要取看一个重要的Worker类。该类封装了线程及任务，可以在内部执行任务，具体定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">    <span class="comment">//具体线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//线程要执行的任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//线程完成的任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//调用线程工厂创建新的线程，threadFactory由我们的线程池构造函数传入，没有指定则使用默认的，这块会创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以看出Worker实现了AQS，其本身也是不可重入锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      思考为什么Worker要继承AQS实现一个独占锁？这个问题我们后面分析。</p><p>​     了解了worker的构成，我们就可以具体看下addWorker函数的执行逻辑了，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core为true，那么创建线程是以corePoolSize作为线程数最大值，否则以maximumPoolSize作为线程数最大值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 线程状态是非RUNNING状态不再进行任务提交处理，其中SHUTDOWN状态下已经提交进行任务和阻塞队列         中的任务要继续处理</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">//线程池中线程大于最大线程数或者大于要求的阈值，返回失败</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//符合要求后，CAS增大线程数，跳出自旋，走下面的线程创建逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;<span class="comment">//标记线程是否启动</span></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;<span class="comment">//标记线程是否添加成功</span></span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建新的线程并封装为一个Work对象</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                    <span class="comment">//对线程池创建的线程状态进行检查</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">//如果新线程检查成功，将新线程加入workers中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            <span class="comment">//更新全局变量，线程池达到的最大线程数，该值可以输出作为线程池参数设定的指标</span></span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">//这块重要了，线程创建成功后，开始执行任务</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​       我们继续跟着上述代码思路走，看下任务如何执行，t.start()的会调用Worker类run()方法，而该方法会调用runWorker来从任务队列中获取任务，执行任务，具体看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果Worker中创建时存在任务，则执行；否则，调用getTask从阻塞队列中获取任务，当阻塞队列中没有任务并且线程不应该被回收时，线程会一直阻塞等待获取任务，具体在getTask方法中分析</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 上面的英文注释很清楚了，这块为了处理调用shutdownNow时需要停止所有的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这个函数可以自己实现，默认为空</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行具体任务的业务逻辑</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//这个函数可以自己实现，默认为空</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//执行线程销毁过程</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在getTask方法中，  Worker线程会一直循环的从阻塞队列中获取任务，直到遇到以下情况会返回null，进而执行上面的线程销毁过程processWorkerExit：</p><p>(1) 线程池状态为SHUTDOWN并且任务队列为空；</p><p>(2) 线程数状态变大于SHUTDOWN (STOP TIDYING TERMINATED);</p><p>(3) 线程池线程数大于最大线程数或者线程超时未获取任务的情况下，任务队列为空或者工作线程数大于1；</p><p> 这块逻辑具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            // 线程池状态为STOP或者（状态为SHUTDOWN&amp;&amp;任务队列为空），这个时候无需在执行任务</span><br><span class="line">            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            //设置了允许核心线程超过keepAliveTime空闲后销毁线程 或者 线程数大于核心线程数</span><br><span class="line">            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            </span><br><span class="line">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">                if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    return null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">               //从阻塞队列中获取任务，如果进行超时控制，则调用poll方法，否则调用take一直阻塞到队列中有任务</span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                if (r != null)</span><br><span class="line">                    return r;</span><br><span class="line">                timedOut = true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        以上就是线程池中任务执行的大致过程，接下来我们对线程池结束及其中实现的一些细节进行分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​      线程作为系统稀缺资源，如果在应用中进行频繁的创建和销毁，会为我们的应用带来灾难性的体验，增大系统负荷，降低效率。池化技术为该问
      
    
    </summary>
    
      <category term="java多线程" scheme="https://www.yuanqiongqiong.cn/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="多线程" scheme="https://www.yuanqiongqiong.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://www.yuanqiongqiong.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈FutureTask的实现</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/08/%E8%B0%88%E8%B0%88FutureTask%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/08/谈谈FutureTask的实现/</id>
    <published>2019-04-08T14:40:19.000Z</published>
    <updated>2019-04-09T05:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​       在使用java多线程解决问题的时候，为了提高效率，我们常常会异步处理一些计算任务并在最后异步的获取计算结果，这个过程的实现离不开Future接口及其实现类FutureTask。FutureTask类实现了Runnable, Future接口，接下来我会通过源码对该类的实现进行详解。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>​       我们先看下FutureTask中的主要方法如下，可以看出FutureTask实现了任务及异步结果的集合功能。看到这块的方法，大家肯定会有疑问，Runnable任务的run方法返回空，FutureTask如何依靠该方法获取线程异步执行结果，这个问题，我们在下面给大家介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下五个方法实现接口Future中方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;           </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//实现接口Runnable中方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>​        我们在使用中会构造一个FutureTask对象，然后将FutureTask扔到另一个线程中执行，而主线程继续执行其他业务逻辑，一段时间后主线程调用FutureTask的get方法获取执行结果。下面我们看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yuanqiongqiong on 2019/4/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        Callable callable = <span class="keyword">new</span> AccCallable(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">        executorService.execute(futureTask);</span><br><span class="line">        System.out.println(<span class="string">"go to do other things in main thread"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"go back in main thread"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = (<span class="keyword">int</span>) futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"result is "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AccCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AccCallable</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"acc a and b in threadId = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><code>go to do other things in main threadacc a and b in threadId = pool-1-thread-1go back in main threadresult is 3</code></p><h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>​        在分析实现前，我们先想下如果让我们实现一个类似FutureTask的功能，我们会如何做？因为需要获取执行结果，需要一个Object对象来存执行结果。任务执行时间不可控性，我们需要一个变量表示执行状态。其他线程会调用get方法获取结果，在没达到超时的时候需要将线程阻塞或挂起。因此需要一个队列类似的结构存储等待该结果的线程信息，这样在任务执行线程完成后就可以唤醒这些阻塞或挂起的线程，得到结果。FutureTask的实际实现也是类似的逻辑，具体如下。</p><p>​        首先看下FutureTask的主要成员变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//futureTask执行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//具体的执行任务，会在run方法中抵用callable.call()</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"><span class="comment">//获取结果的等待线程节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><p>​         对于执行状态，在源码中已经有了非常清晰的解释，这里我只是贴出源码，不在进行说明，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Possible state transitions:</span><br><span class="line">  * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">  * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">  * NEW -&gt; CANCELLED</span><br><span class="line">  * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line">  */</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br></pre></td></tr></table></figure><p>​         然后我们看下FutureTask的构造函数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造函数传入runnable对象时调用静态工具类Executors的方法转换为一个callable对象</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如前所述，FutureTask的执行线程中会调用其run()方法执行任务，我们看下这块逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.如果执行状态不是NEW或者有其他线程执行该任务，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">//2.如果执行状态是NEW,即任务还没执行，直接调用callable.call()方法获取执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//3.发生异常，更新status为EXCEPTIONAL，唤醒挂起线程</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4.如果结果成功返回，调用set方法将设置outcome，更改status执行状态，唤醒挂起线程</span></span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​     我们看下set函数的实现，具体看下4中的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//将执行状态变更为COMPLETING</span></span><br><span class="line">       <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">           <span class="comment">//设置执行结果</span></span><br><span class="line">           outcome = v;</span><br><span class="line">           <span class="comment">//设置执行状态为NORMAL</span></span><br><span class="line">           UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">           <span class="comment">//执行完成后处理操作，具体就是遍历阻塞链表，删除链表节点，并唤醒每个节点关联的线程</span></span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​       以上就是任务执行线程做的逻辑，以上逻辑也回答了FutureTask如何得到执行结果的疑问。下面我们看下用户调用get方法获取执行结果时的实现逻辑，这个时候FutureTask可能处理各种状态，即可能没有执行，执行中，已完成，发生异常等，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//执行状态是NEW或者COMPLETING时执行awaitDone将线程加入等待队列中并挂起线程</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="comment">//根据执行状态status进行结果封装</span></span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我理解这块是get的核心逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//如果设置了超时时间，计算还有多长时间超时</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//如果当前线程被中断，删除等待队列中的节点，并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">//如果执行状态已经完成或者发生异常，直接跳出自旋返回</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果执行状态是正在执行，说明线程已经被加入到等待队列中，放弃cpu进入下次循环(真正的自旋)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="comment">//第一次进入循环，创建节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="comment">//将节点加入到等待队列中，waiters相当于头阶段，不断将头结点更新为新节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="comment">//如果设置了超时时间，在进行下次循环前查看是否已经超时，如果超时删除该节点进行返回</span></span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//挂起当前节点</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​       这里需要说明一点，FutureTask中的阻塞队列新加入的节点都在头结点并且next指向之前的头结点，waitars指针总是指向新加入节点，通过waitars可以遍历整个等待队列，具体截图如下。此外等待队列节点结构很简单成员变量只有线程引用和next指针，这里再列出器接口。</p><p><img src="/2019/04/08/谈谈FutureTask的实现/futureTask等待队列.png" alt></p><p>​        读到这里，相信大家已经对FutureTask的实现细节有了一定的认识。此外，FutureTask没有使用锁而是使用Unsafe的是CAS的原子操作来解决竞争问题，减少了锁带来的上下文切换的开销，提高了效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​       在使用java多线程解决问题的时候，为了提高效率，我们常常会异步处理一些计算任务并在最后异步的获取计算结果，这个过程的实现离
      
    
    </summary>
    
      <category term="java多线程" scheme="https://www.yuanqiongqiong.cn/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="多线程" scheme="https://www.yuanqiongqiong.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://www.yuanqiongqiong.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从java类加载机制解析变量初始化</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/06/%E4%BB%8Ejava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/06/从java类加载机制解析变量初始化/</id>
    <published>2019-04-06T02:41:41.000Z</published>
    <updated>2019-04-06T06:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​         java类加载机制对我来说总是熟悉又陌生，之前也单独是进行了解过，但总是当时很明白，过了一段时间这块又忘的差不多了。所以，想通过这篇文章对这块知识进行详细的总结。</p><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><p>​        我们知道java代码是运行在jvm上的，这个过程需要经过将源代码编译为class字节码，然后将字节码装载到jvm中行程其可以使用的java类型，这个装载的过程就是java类的加载机制。Java类加载过程可以分为加载，验证，准备，解析，初始化五个阶段，其中验证，准备，解析三个阶段又可以称为连接过程。可以看出，java的连接工作发生在运行期，这为程序提供了高度的灵活性(java 动态扩展特性依赖于此)。下面，我们先看下结合java加载机制后的类对象声明周期图示，然后对相关阶段进行详细介绍。</p><p><img src="/2019/04/06/从java类加载机制解析变量初始化/jvmload.png" alt></p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>​        jvm并没有对类的加载时机进行明确的规范，但是却对类的初始化时机进行了严格的规定（在进行初始化的时候，加载，验证，准备，解析必须完成）。jvm规定必须在“initialize on first active use”是对类进行初始化，即首次使用时必须对类进行初始化。以下几种情况会触发类的初始化过程：</p><p>（1）创建一个类的实例时，new、反射、克隆或反序列化；</p><p>（2）调用某个类的静态方法时；</p><p>（3）使用某个类或接口的静态字段或对该字段赋值时（final字段除外）；</p><p>（4）调用Java的某些反射方法时；</p><p>（5）初始化某个类的子类时；</p><p>（6）在虚拟机启动时某个含有main()方法的那个启动类。</p><p>​         需要注意的是：（1）同一个类在同一个类加载器下只能初始化一次；（2）引用在编译期就能确定的静态常量不会触发初始化；（3）在初始化前必须进行加载和链接；（4）如果这个类有父类并且这个父类没有被初始化,则先初始化父类。</p><h2 id="各阶段介绍"><a href="#各阶段介绍" class="headerlink" title="各阶段介绍"></a>各阶段介绍</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>​     在该阶段，jvm需要完成以下3件事：</p><p>（1）通过一个类的全限定名来获取定义此类的二进制字节流，这个字节流可以来自class文件，网络io，或者动态生成（即动态代理技术的基础）；</p><p>（2）<strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</strong></p><p>（3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。（对于hotspot，Class对象比较特殊，存在于方法区）。</p><p>​     需要说明的是对于数组类而言，本身不通过类加载器创建，它是由java虚拟机直接创建的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​      该阶段是为了保证加载的Class文件符合虚拟机的要求，不会危及虚拟机自身的安全，主要有一下四个检验阶段：</p><p>（1）文件格式验证<br>主要验证字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。<br>（2）元数据验证<br>是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范要求。<br>（3）字节码验证<br>主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。<br>（4）符号引用验证<br>     发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析中。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>​      该阶段正式为类变量分配内存并进行初始化，注意是类变量而不是实例变量，该阶段内存分配发生在方法区。<strong>在该阶段完成后类变量会被置为默认值（final类型的静态变量除外）。</strong></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>​      该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。需要对符号引用和常量引用进行说明如下：</p><p>（1）符号引用</p><p>​      符号引用以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</p><p>（2）直接引用</p><p>​     直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位目标的句柄，它是与虚拟机的内存布局相关的，如果有了直接引用，那引用的目标必定已经存在于内存中。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​      该阶段才真正开始执行类定义中的java程序代码，初始化阶段是执行类构造器<clinit>()方法的过程，<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，虚拟机中第一个被执行的<clint>()方法的类肯定是java.lang.Object，静态语句块中只能访问到定义在静态语句块之前的变量。同一个类加载器下，一个类型只能被初始化一次。</clint></clinit></clinit></p><h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><p>​     看下下面这段程序，思考下输出会是啥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by yuanqiongqiong on 2019/4/6.</span><br><span class="line"> */</span><br><span class="line">public class StaticTest &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    static StaticTest st = new StaticTest();</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    StaticTest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;3&quot;);</span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void staticFunction()&#123;</span><br><span class="line">        System.out.println(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int a=110;</span><br><span class="line">    static int b =112;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     输出：</p><p><code>23a=110,b=014</code></p><p>​      如果理解了上面讲的类加载过程，这个结果应该很好理解。首先我们看StaticTest的初始化时机，在main方法中调用静态方法staticFunction()，在初始化前会首先进行类的加载过程。经过加载，链接过程后静态变量st=null，b=0。</p><p>​      然后执行初始化阶段，上述的clinit应该包含如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">112</span>;</span><br></pre></td></tr></table></figure><p>​      首先执行构造函数，这个时候会先对成员变量初始化，即设置a=110，然后执行代码块（先于构造函数里语句执行）。这里可能大家会觉得StaticTest类的初始化阶段还没完成就开始执行构造函数初始化实例变量，其实我理解这块并没有问题，因为在连接阶段后Class对象已经在方法区了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     最后执行构造函数的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"3"</span>);</span><br><span class="line">System.out.println(<span class="string">"a="</span>+a+<span class="string">",b="</span>+b);</span><br></pre></td></tr></table></figure><p>​     完成上述初始化阶段后，执行staticFunction函数。以上就是上述代码的执行整体流程，相信大家对输出应该没有异议了。</p><p>​     如果再上述代码里将变量b的类型改为static final，那么b的输出值即为112。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>​      上述类加载过程是由jvm的类加载器完成，java中默认的类加载器有Bootstrap ClassLoader，Extension ClassLoader，App ClassLoader，分别负责的加载不同的类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。所以，hotspot使用双亲委派模型保证一个类只能被加载一次，确立了其在虚拟机中的唯一性。</p><p>1）Bootstrap ClassLoader</p><p>​     启动类加载器，负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar中的class。</p><p>（2）Extension ClassLoader</p><p>​    扩展类加载器，负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar。</p><p>（3）App ClassLoader</p><p>​    系统类加载器，负责加载当前java应用的classpath中的所有类。</p><p>​     双亲委派模型就是一个类收到类加载请求后，它首先不会尝试自己加载这个类，而是把这个请求委派为父类加载器取处理。因此，所有的请求都会送到顶层的启动类加载器中，只有父类无法加载请求，子加载器才会尝试自己去加载。</p><p><img src="/2019/04/06/从java类加载机制解析变量初始化/jvmload2.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《深入理解java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​         java类加载机制对我来说总是熟悉又陌生，之前也单独是进行了解过，但总是当时很明白，过了一段时间这块又忘的差不多了。所以
      
    
    </summary>
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MAT中指标解释</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/05/MAT%E4%B8%AD%E6%8C%87%E6%A0%87%E8%A7%A3%E9%87%8A/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/05/MAT中指标解释/</id>
    <published>2019-04-05T14:46:40.000Z</published>
    <updated>2019-04-05T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>​       在用MAT进行内存快照分析时会看到有两个指标Shallow Heap和Retained Heap，下面给出这两个指标的含义：</p><p>（1）Shallow Heap</p><p>​       中文释义“表面上的堆大小”指的是对象本身占有内存的大小，不包含其引用对象的大小。常规对象该指标是对象的数量和类型的大小决定，数据则由类型的大小和数据的长度决定。</p><p>（2）Retained Heap</p><p>​       中文释义“持有的堆的大小”指的是当该对象被回收时那些将被回收的对象集合多有对象大小叠加的大小（包括其本身大小）。例如有一个ArrayList持有10个对象，每个对象带下是4bytes，其本身的大小是X，那么其Retained Heap则为10 * 4 + X。</p><p>下面给出MAT中相关截图：</p><p><img src="/2019/04/05/MAT中指标解释/mat.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​       在用MAT进行内存快照分析时会看到有两个指标Shallow Heap和Retained Heap，下面给出这两个指标的含义：&lt;/p&gt;
&lt;p&gt;（1）Shallow Heap&lt;/p&gt;
&lt;p&gt;​       中文释义“表面上的堆大小”指的是对象本身占有内存的大小，
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>从String.intern()方法浅谈堆中常量池</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/04/%E4%BB%8EString-intern-%E6%96%B9%E6%B3%95%E6%B5%85%E8%B0%88%E5%A0%86%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/04/从String-intern-方法浅谈堆中常量池/</id>
    <published>2019-04-04T15:27:08.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​       String是我们最常用的一个类，和普通java类一样其对象会存在java堆中。但是String类有其特殊之处，可以通过new方法生成，也可以通过带引号的字符串常量直接赋值。在JDK7之前，字符串常量是存在永久带Perm 区的，JDK7开始在将常量池迁移到堆中，这个变化也导致了String的新特性，下面我们慢慢进行介绍。</p><h1 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h1><p>简单的说，String.intern()方法的作用就是返回常量池中字符串对象，在对该方法进行详解之前，我们看几个创建字符串对象的例子。以下说明及运行结果都是以JDK8为java环境。</p><p>（1）直接赋值字符串常量</p><p>​      这种方式会判断常量池中是否存在字符串常量，如果存在返回该常量对象，否则在常量池中创建常量对象并返回。</p><p><code>//在常量池中创建常量“abc”，s1,s2指向常量池中对象地址        String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//true</code></p><p>（2）通过new关键字创建</p><p>​      这种方式会在堆上创建String对象，如果常量池中没有该常量，将常量加入常量池中。</p><p><code>//在堆上创建对象S3,S4,常量池中创建对象“abc”String s3 = new String(&quot;abc&quot;);String s4 = new String(&quot;abc&quot;);System.out.println(s3 == s4);//false</code></p><p>（3）字符串常量相加</p><p>​       这种方式如s5，会在常量池中创建”cd”,”ef”,”cdef”三个对象，s5指向常量池中的”cdef”对象。</p><p><code>String s5 = &quot;cd&quot; + &quot;ef&quot;;String s6 = &quot;cdef&quot;;System.out.println(s5==s6);//true</code></p><p>（4）两个new的String对象相加</p><p>​      这种方式如s7，会在堆中创建三个对象”gh”对象，”lm”对象，以及”ghlm”对象，在常量池中创建对象”gh”,”lm”。</p><p><code>String s7 = new String(&quot;gh&quot;) + new String(&quot;lm&quot;);String s8 = &quot;ghlm&quot;;System.out.println(s7==s8);//false</code></p><p>（5）字符串常量与new的String对象相加</p><p>​     这种方式如s9，会在堆中创建两个对象“op”，“mnop”，并将字符串常量“op”, “mn”加到常量池中。</p><p><code>String s9 = &quot;mn&quot; + new String(&quot;op&quot;);String s10 = &quot;mnop&quot;;System.out.println(s9==s10);//false</code></p><p>​     了解字符串常量的创建及其在内存中的存储，我们看native方法intern()的作用：判断String对象的常量值是否存在于常量池中，如果存在并且是常量池对象，返回该常量池对象；如果存在并且是指向堆中的对象，返回堆中对象地址；如果不存在，则将对象的引用复制到常量池，并返回该对象的引用。下面我们看几条语句的运行结果，第一个输出之所以为true，</p><p><code>String s11 = new String(&quot;a&quot;) + new String(&quot;a&quot;);s11.intern();//由于常量池中无“aa”,因此在常量池中建“aa”的引用,指向堆中的s11String s12 = &quot;aa&quot;;//s12指向常量池中的对象（该对象指向S11）System.out.println(s11 == s12.intern());//trueString s13 = new String(&quot;b&quot;);s13.intern();//常量池中已经有“b”了，不做任何操作String s14 = &quot;b&quot;;System.out.println(s13==s14.intern());//false</code></p><p>​      如果理解了以上运行的结果，对intern()方法的左右就掌握的差不多了。那么久可以开始我们的主题，string pool，字符串常量池。</p><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>​       字符串常量池是jvm为了减小内存开销而在创建字符串对象时的一个优化，类似缓冲区。在hotspot中，字符串常量池是一个叫做StringTable的HashTable，默认长度是1009，在JDK7开始可以通过”-XX:StringTableSize=1009” 参数来设置，字符串常量池数据可以被gc回收（在JDK6及其以前，字符串常量存在永久带无法被gc回收，如果添加太多字符串常量到该区域，容易发生OOM）。由于字符串常量池是利用HashTable实现，因此一定会发生hash碰撞。jvm在这方面做了一定优化，会根据hashTable的碰撞情况来决定是否做rehash，当从这个StringTable里查找某个字符串是否存在，如果对其对应的桶链表进行遍历，遍历超过了100个节点还是没有找到，那就会设置一个flag，让下次进入到safepoint的时候做一次rehash动作，尽量减少碰撞的发生。当然，在数据量比较大的情况下，这也无法从根本上解决问题，只能设置StringTableSize的值来缓解。</p><p>​       由于JDK7开始字符串常量池在堆中分布，所以young gc过程会扫描该区域，以保证处于新生代的String对象不会被回收掉，因此如果字符串常量区非常庞大会导致young gc过程扫描的时间也会变长。但是，young gc阶段并不会对字符串常量区进行回收，具体回收阶段是在Full gc或者CMS gc阶段（题外话：我觉得full gc这个名字并不是很好，容易理解为对所有区域进行回收，其实full GC是对老年代的STW的gc，full gc的次数是老年代gc的STW次数，时间是老年代STW的总时间）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​       String是我们最常用的一个类，和普通java类一样其对象会存在java堆中。但是String类有其特殊之处，可以通过ne
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="java" scheme="https://www.yuanqiongqiong.cn/tags/java/"/>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>对full gc, cms gc, magor gc的疑问</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/04/gc%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/04/gc定义解析/</id>
    <published>2019-04-04T01:34:54.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​        在日常的学习和问题排查中，我们经常会遇到full gc，cms gc，magor gc这几个概念，而对这几个概念的理解可能会有些偏差。如果单纯从名词解析上来讲，执着的弄清楚这几个概念可能就是在浪费时间。但是，如果可以通过对概念的辨析加深对java垃圾回收的理解，这些时间也是值得的。这里，我将对这几个概念进一步理解，纠正自己以前的错误认知。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h3 id="cms-gc"><a href="#cms-gc" class="headerlink" title="cms gc"></a>cms gc</h3><p>​        cms垃圾回收算法是我们线上使用的老年垃圾回收算法，以其较短的停顿时间而被广泛应用，也是jvm中最重要的一个垃圾回收算法。顾名思义，cms gc就是cms回收算法中的各个步骤，这里既有导致STW的初始标记阶段和最终标记阶段，也有和应用线程并发执行的其他阶段，它们都是cms gc。</p><h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>​        我理解full gc就是针对老年代/metaspace区域（Java8之前为永久带）进行的可以导致STW的gc。这里面有个重要的点，只有导致STW的gc才能成为full gc。以我们对cms 算法的了解，如果cms算法正常运行，会发生两次STW。那么以我们讲的概念这样的cms gc会带到两次full gc，下面我们通过jstate命令以及gc日志中cms gc发生的次数来验证这个问题。以我们线上一台机器为例：我们看下统计full gc的数量如下，看出发生了4次full gc。</p><p><img src="/2019/04/04/gc定义解析/gc4.png" alt="gc4"></p><p>​       我们看gc日志看到full 2是最大的cms数量，也就是发生两次cms gc，如上面我们的计算相符。具体如下图：</p><p><img src="/2019/04/04/gc定义解析/gc5.png" alt="gc5"></p><p>​         所以可以这样说，cms中的STW的阶段属于full gc，其他阶段不属于full gc。</p><p>​        正常的full的时间不会很长，如上面的平均时间是0.718/4=0.1795s，但是异常情况下，如如果发生了promotion failed，或者concurrent model failure现象，STW的时间就会很长。这两种情况下的gc并不是由gc线程来执行的，<strong>而是由vm thread 执行的</strong>，整个过程都会STW。先说promotion failed，这是由于在年轻带发生young gc时，eden区晋升的对象，在survivor中发不下，导致年轻带放弃young gc而直接由vm 线程触发一次老年代的gc，这个过程只有单线程执行，完全的STW，因此时间比较长。下面我们看一个promotion failed的例子，我们看到发生了9次full gc。</p><p><img src="/2019/04/04/gc定义解析/gc6.png" alt></p><p>​        查看gc日志，我们看到第五次cms gc是promotion failed引起的且时间用了3.84s，我们计算full gc的次数为4次正常的cms gc带来的8次full gc 加 一次vm thread触发的full gc，一共9次。</p><p><img src="/2019/04/04/gc定义解析/gc7.png" alt></p><p>​        说完promotion failed，我们要说一下concurrent model failure，如果cms gc在执行过程中vm 线程触发了一次full gc，那么这个时候就会产生concurrent model failure，这个时候问题会更加严重，垃圾回收算法会退化为Serail Old，单线程执行，切完全的STW。其实，这里讲的vm 线程触发的full gc和正常的cms gc的实现都在concurrentMarkSweepGeneration.cpp，只不过有着不同的执行路径，vm线程触发的full gc又被称为The background collector，而正常的cms算法被称为The foreground collector。从英文名字中可以清晰的明白前者是后台触发的，而后者是由相应线程主动触发的。</p><h3 id="magor-gc"><a href="#magor-gc" class="headerlink" title="magor gc"></a>magor gc</h3><p>​       我理解的magor gc就是full gc，他们是同一个概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;​        在日常的学习和问题排查中，我们经常会遇到full gc，cms gc，magor gc这几个概念，而对这几个概念的理解可能
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>从gc日志学习gc相关知识</title>
    <link href="https://www.yuanqiongqiong.cn/2019/04/03/gc%E6%97%A5%E5%BF%97/"/>
    <id>https://www.yuanqiongqiong.cn/2019/04/03/gc日志/</id>
    <published>2019-04-03T11:45:10.000Z</published>
    <updated>2019-04-05T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​       最近又对gc有了很大的兴趣，重新对之前gc相关的知识进行学习，其实是看了寒泉子大神gc相关的博客，觉得真的是厉害，这里先记录下如何去阅读gc日志吧。</p><h1 id="gc日志解读"><a href="#gc日志解读" class="headerlink" title="gc日志解读"></a>gc日志解读</h1><h2 id="young-gc-日志"><a href="#young-gc-日志" class="headerlink" title="young gc 日志"></a>young gc 日志</h2><p>我们通过具体的日志进行讲解，如下：</p><p><img src="https://i.bmp.ovh/imgs/2019/04/a6e1021877073145.png" alt>)</p><p>最前面的”Allocation Failure”表示young gc原因，ParNew表示年轻代使用串行多线程垃圾回收器。</p><p>1.表示年轻代垃圾回收期使用的是ParNew;</p><p>2.年轻代回收前使用的大小是81920K;</p><p>3.年轻代回收后使用大小是9566K，可以推断出回收对象大小是81920k-9566k=72354k；</p><p><img src="https://i.bmp.ovh/imgs/2019/04/0f71ecb09d7b9255.png" alt></p><p>5.年轻带垃圾回收的时间；</p><p>6.回收前整个堆的使用大小；</p><p>7.回收后整个堆的使用大小；</p><p>9.这个堆内存回收使用的时间；</p><p>10.指的是gc线程在用户态的时间，如果是多线程的gc算法，该时间是叠加了多线程的时间；</p><p>11.指的是gc线程在内核态的时间，如果是多线程的gc算法，该时间是叠加了多线程的时间；</p><p>12.指的是gc操作从开始到结束的墙钟时间，包括各种非运算的耗时，例如等待磁盘IO，等待线程阻塞，而CPU事件不包括这些事件。我理解这块时间就是gc操作从开始到结束的全部时间。应用程序暂停的时间，对于使用串行垃圾收集时real 大致等于 sys + user; 如下图是使用serial串行垃圾回收算法各部分时间（real 大致等于 sys + user，个人感觉是舍入规则导致不完全相等）。</p><p><img src="https://i.bmp.ovh/imgs/2019/04/212f99d94fc26190.png" alt></p><h2 id="full-gc-（CMS）日志"><a href="#full-gc-（CMS）日志" class="headerlink" title="full gc （CMS）日志"></a>full gc （CMS）日志</h2><p>CMS是老年代垃圾回收算法，由于其避免了长时间的停顿被广泛应用，我们线上老年代都使用的这种算法。下面进行相关讲解：</p><ul><li>阶段一：初始标记（CMS Initial Mark）</li></ul><p>该阶段应用线程会进行一次STW，是CMS算法中两次STW之一，主要工作是：标记GC ROOTS 可达大老年代对象，标记年轻带对象引用的老年代对象。该阶段不会对间接引用对象进行关联，因此该阶段很快。</p><ul><li>阶段二：并发标记（CMS-concurrent-mark）</li></ul><p>该阶段会通过对阶段一标记出的老年带对象进行递归标记，标记处可达的所有对象。该阶段与应用线程是并发执行，因此会出现阶段一种标记的对象引用发生变化，或年轻带对象晋升到老年带，或对象直接分配到老年等情况，在该阶段也会把这些对象所在的Card标记为Dirty，以便在下个阶段处理。</p><ul><li>阶段三：并发预清理（CMS-concurrent-preclean）</li></ul><p>该阶段主要做两件事，一个是处理在并发标记阶段标记的Dirty Card中对象，重新标记引用发生变化的对象；另一个是在并发标记阶段会出现新生代新对象引用老年代对象，这个阶段需要标记这些对象。该阶段和应用线程是并发执行的，可以通过参数CMSPrecleaningEnabled关闭该对象。</p><ul><li>阶段四：可中断预清理（CMS-concurrent-abortable-preclean）</li></ul><p>由于在重新标记阶段会进行CMS中另一次STW，对老年代活跃对象进行重新标记，因此为了减小重新标记阶段阶段STW的时间，在重新标记阶段之前加入该过程进行一定的清理工作。该阶段发生的条件是eden区内存使用量大于CMSScheduleRemarkEdenSizeThreshold，默认是2M。因此该阶段主要工作一个是处理Dirty Card中的对象；另一个是处理年轻带对象，标记活跃的老年代对象。该阶段和应用线程并发进行，会循环执行下去，直到时间达到CMSMaxAbortablePrecleanTime（默认5s）或者次数达到CMSMaxAbortablePrecleanLoops（默认无限制）或者eden区使用率达到CMSScheduleRemarkEdenPenetration（默认50%）。可以知道，该阶段会扫描年轻带对象，如果再该阶段之前进行一次young gc 减小年轻带活跃对象数目，会加快该阶段速度，可以通过参数CMSScavengeBeforeRemark来控制。</p><ul><li>阶段五：重新标记（CMS Final Remark）</li></ul><p>如上所述，该阶段是CMS中另一个STW阶段，需要尽可能的减小该阶段时间，上面的阶段三，阶段四的存在正式为了这一点。该阶段的工作一个是遍历GC ROOTS 进行重新标记，一个是遍历新生代对象重新标记，另一个是遍历Dirty Card重新标记。</p><ul><li>阶段六：清理阶段（CMS-concurrent-sweep）</li></ul><p>该阶段会清理不活跃的老年代对象，该阶段与应用线程并发进行。</p><ul><li>阶段七：重置阶段</li></ul><p>该阶段会重置CMS算法相关的数据结构，为下次gc做准备，该阶段与应用线程并发执行。</p><p>老年代gc回收的相关日志如下，这里不进行解读，容量，时间相关参数和年轻大大致类似。</p><p><code>1.803: [CMS-concurrent-mark-start]1.957: [GC (Allocation Failure) 1.958: [ParNew: 92159K-&gt;10239K(92160K), 0.1382680 secs] 565579K-&gt;565578K(1038336K), 0.1383043 secs] [Times: user=0.81 sys=0.05, real=0.14 secs] 2.163: [GC (Allocation Failure) 2.163: [ParNew: 92159K-&gt;10239K(92160K), 0.1259734 secs] 647498K-&gt;647496K(1038336K), 0.1260101 secs] [Times: user=0.70 sys=0.04, real=0.12 secs] 2157ms2.671: [CMS-concurrent-mark: 0.603/0.867 secs] [Times: user=2.77 sys=0.10, real=0.86 secs] 2.671: [CMS-concurrent-preclean-start]2.842: [CMS-concurrent-preclean: 0.172/0.172 secs] [Times: user=0.17 sys=0.00, real=0.18 secs] 2.842: [CMS-concurrent-abortable-preclean-start] CMS: abort preclean due to time 7.996: [CMS-concurrent-abortable-preclean: 2.430/5.153 secs] [Times: user=2.41 sys=0.01, real=5.15 secs] 7.996: [GC (CMS Final Remark) [YG occupancy: 28252 K (92160 K)]7.996: [Rescan (parallel) , 0.0047059 secs]8.001: [weak refs processing, 0.0000344 secs]8.001: [class unloading, 0.0002629 secs]8.001: [scrub symbol table, 0.0005571 secs]8.002: [scrub string table, 0.0001773 secs][1 CMS-remark: 637257K(946176K)] 665509K(1038336K), 0.0058199 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] 8.002: [CMS-concurrent-sweep-start]8.353: [CMS-concurrent-sweep: 0.351/0.351 secs] [Times: user=0.35 sys=0.00, real=0.35 secs] 8.353: [CMS-concurrent-reset-start]8.356: [CMS-concurrent-reset: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></p><p>full gc是我们比较担心的事情，因为会出现较长的STW，那么什么情况下会触发full gc呢，下面我列出几种情况：</p><ul><li>老年代使用率达到阈值 CMSInitiatingOccupancyFraction（该值默认是92%）；</li><li>新生代晋升担保失败，也就是由于新生代survivor区域大小无法容纳eden区存活的对象，直接晋升到老年代，老年代没有足够空间，需要进行一次full gc。</li><li>代码执行System.gc()并且没有参数ExplicitGCInvokesConcurrent，也会触发full gc；</li><li>jdk1.7及之前还存在永久代时，在开启 CMSClassUnloadingEnabled时，如果永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction（该值默认是92%）。在jdk1.8及以后永久代被metaspace替代，metaspace区域也是使用cms进行垃圾回收，可以设置该区域发生gc的初始阈值的MetaspaceSize，但是该阈值会一直变化，对该区域参数的相关介绍可以参考<a href="https://mp.weixin.qq.com/s/SsXbRvtvawKDHstFpU4uog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SsXbRvtvawKDHstFpU4uog</a> 。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​       最近又对gc有了很大的兴趣，重新对之前gc相关的知识进行学习，其实是看了寒泉子大神gc相关的博客，觉得真的是厉害，这里先记录
      
    
    </summary>
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.yuanqiongqiong.cn/tags/jvm/"/>
    
  </entry>
  
</feed>
